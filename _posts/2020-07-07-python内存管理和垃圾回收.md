---
layout: post
title: python内存管理和垃圾回收
date: 2020-07-07
categories:
- python
---



* Python的内存管理和垃圾回收机制<br>
  Python的内存管理机制(三种)<br>

  * 1.引用计数 -- 实时性,引用为0立即回收
     * 对象不再被引用时, 引用计数减1, 直到减为0时对象被删除
   * 2.垃圾回收
      * 引用计数, 也算是一种垃圾回收, 但是如果循环引用就不起作用了!!
     * 标记清除,去除循环引用

     * 分代回收 

          * 多次清理后依然存在的内存块-->放入集合A中
            新的内存块-->放入集合B中
            清理内存时先对B进行操作,一段时间后再对A进行操作
            经过分代,每次处理的内存明显减少,大大提升清理效率
            集合A中的一些垃圾会因为分代而被延迟清理
  * 3.内存池
      * Python的内存机制是金字塔形
        最底层-1和-2层主要由操作系统进行操作
        第0层由C中malloc和free这些内存分配和释放函数操作
        第1层和第2层就是内存池,由Python的接口函数PyMem_Malloc函数实现,如果对象小于256k时由该层直接分配内存
        第3层也就是最上层,由程序员对Python对象直接操作
      * Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切
        换，这将严重影响 Python 的执行效率。为了加速Python 的执行效率，Python 引入了一个内存池
        机制，用于管理对小块内存的申请和释放。
      * Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节
        时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的
        行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改
        变 Python 的默认内存管理行为。
      * 预先在内存中申请一定数量的,大小相等的内存块备用
      * 目的:减少内存碎片,提升效率
       * 调优手段
          1.手动回收垃圾
          2.调高垃圾回收的阈值
          3.避免循环引用(手动解除循环引用,使用弱引用)

* 内存泄漏(内存消失)
  -非物理上的内存消失,而是因为程序设计失误导致失去对某块内存的控制
  -程序未能释放已经不使用的内存
  -造成内存浪费、程序运行速度减慢甚至系统崩溃等严重后果
  主因:
  有__del__()函数的对象之间的循环引用
  防止: 
  
  1. del(对象)直接手动删除不需要的对象
  2. gc模块查看不能回收的对象信息
3. sys.getrefcount(对象)查看引用计数是否为0
  
* 垃圾回收机制如何解决循环引用
  
  
  