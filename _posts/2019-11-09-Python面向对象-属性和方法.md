---
layout: post
title: Python面向对象 -- 属性和方法
date: 2019-11-09
categories:
- python
---
属性分类:
* 私有属性
* 类属性
* 实例属性

方法分类:
* 私有方法
* 类方法
* 实例方法
* 静态方法

### 私有
* 私有属性: 只能在类的内部使用, 不能在类的外部使用<br>
* 私有方法: 不能在子类中使用, 不会被继承<br>

如果想在类的外部获取私有属性的值, 则需要在类的内部定义一个公有方法, 然后在类的外部去调用这个公有方法来访问私有属性<br>
```python
def getattr(self):
    return self.__attr
def setattr(self, value):
    self.__attr = value
```

定义私有: 前缀加2个下划线 `__attr`或`__func()`<br>

Python中的私有其实是`伪私有`, 还是可以在类的外部强行修改私有:
* `__类名__属性名`
* `__类名__方法名()`

### 查看方法和属性
```python
# 查看类中的方法和属性
类名.__dict__
# 查看实例对象的方法和属性
对象.__dict__
```
* `__dict__`方法的返回值是字典

### 类
* 类属性
> 1. 描述的是整个类的特点
> 2. 在类的内部, 方法的外部的属性
> 3. 只会在类对象中保存, 只占一份内存
>
> 类属性的操作:
> ```python
> # 修改类属性
> 类名.类属性名 = 数据值
> # 访问类属性
> 类名.类属性名
> 对象.类属性名
> ```
> * `对象.类属性名 = 数据值`并不能修改类属性的值, 而是相当于给实例对象新增了一个与类属性同名的实例属性
> * 当实例属性和类属性重名时, 对象调用的是自己的实例属性
> * 什么时候需要类属性? 每个实例对象都需要一个相同的属性值时, 定义类属性更高效

* 类方法
> 1. 使用`@classmethod`装饰
> 2. 第一个形参是`cls`, 代表类本身
> 3. 在方法的内部不需要实例对象的属性, 只需要类属性的时候, 可以把方法定义成类方法<br>
> 
> 调用类方法
> ```python
> 类名.类方法()
> 对象.类方法()
> ```

### 实例
* 实例属性
	1. 描述某个具体对象的特点
	2. 在方法的内部, 用`self.属性名`定义
	3. 在类的外部, 用`对象.属性名`定义
	4. 实例属性是每创建一个实例对象都会保存一份
* 实例方法
	* 第一个形参是`self`的方法


### 静态方法
1. 使用`@staticmethod`装饰的方法
2. 可以有参数, 也可以没有参数
3. 方法内部既不需要实例属性也不需要类属性的时候, 可以把方法定义成静态方法

调用静态方法:
```python
类名.静态方法()
对象.静态方法()
```


