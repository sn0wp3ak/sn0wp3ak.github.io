---
layout: post
title: MySQl索引数据结构
date: 2020-07-06
categories:
- database
tags:
- mysql
---
## MySQL索引数据结构
MySQL索引一般(99%)采用: B+树 <br>
1. 为什么不采用二叉树(Binary Search Trees)?<br>
答: 单边递增的情况, 使用二叉树无任何提升, 等同于顺序表遍历<br>
2. 为什么不采用红黑树(Red-Black Trees)?<br>
答: 大数据量的情况, 使用红黑树会使层级太多太深, 查找性能也会大幅下降<br>
3. 为什么要用B+树(B+ Trees)?<br>
B+树==多路(叉)平衡树<br>

B+树的特点:<br>
1. 非叶子节点不存数据, 只存索引, 那么一个非叶子节点就能存更多的索引;
2. 叶子节点包含所有的索引字段;
3. 叶子节点指针相连接, 提高区间访问的性能(B+树对B树的改造点)<br>
<img src="/assets/post_image/b+tree.png" width="100%" hegiht="100%"><br>
16KB/(8+6)B=1170(每个节点最多存储的索引个数)<br>
假设叶子节点1KB空间 <br>
1170 X 1170 X 16 = 21902400<br>
存储2000万的数据量只需要3层即可<br>
答: 即使存储大量数据, 依然能够保持较少的层级, 大幅提升查询效率; 在范围查询时, 因为叶子节点有地址指针, 可以提高区间(范围)查找的效率
4. 为什么不采用哈希表(Hash Tables)?<br>
答: 哈希值只适合用于比较是否相等, 而范围查找时, hash表的索引就失效了<br>

## MySQL表的磁盘文件
MyISAM引擎的索引文件和数据文件是分离的(非聚集)<br>

| :-         | :-   |
| 索引文件   | .MYI |
| 数据文件   | .MYD |
| 表结构文件 | .frm |

InnoDB引擎的索引文件和数据文件是一体的(聚集)<br>

|:-|:-|
|索引+数据 文件|.ibd|
|表结构文件|.frm|

聚集: 叶子节点包含完整的数据记录, 而不仅仅是地址指针<br>

## InnoDB表的索引

1. 为什么InnoDB表必须有主键, 并且推荐整形自增主键?<br>
答:<br>
* `1.1` InnoDB的索引是一个聚集B+树, 需要主键作为元素去组织索引树, 所以一般情况下必须有主键; 即使不创建主键, MySQL也会自动找到合适的字段去创建一个主键; 如果实在找不到合适的主键字段, MySQL会创建一个隐藏列, 由这个唯一的隐藏列去维护索引; (为什么必须有主键)
* `1.2` 在查找过程中需要做多次比较大小的操作, 而整形比较大小的时间最短, 也最容易; 而且整形占空间更小, 磁盘的利用率更高(为什么推荐整形)
* `1.3`  非自增的主键索引, 在叶子节点占满16KB时, 再往中间插入索引数据时会分裂成两个叶子节点, 并且还可能引发整棵树的再平衡操作, 效率低下
2. 为什么不建议用uuid去做主键?<br>
答: 首先uuid不是整形而是字符串, 其次uuid不是自增而是随机的<br>
3. 为什么非主键索引结构叶子节点存储的是主键值?<br>
答: 一致性和节省存储空间

## 联合索引底层数据结构
最左前缀原则
