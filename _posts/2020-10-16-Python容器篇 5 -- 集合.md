---
layout: post
title: Python容器篇 5 -- 集合
date: 2020-10-16
categories:
- python
---

**集合**

`set = {item1, item2, ...}`

创建一个空集合:
1. em_set = set() # 只有这一种方式, {}已经被用作创建空字典!

集合这种容器, 貌似是5大容器中最没有存在感, 也确实是用的最少的一种;<br>
但是, 它的作用却很重要!<br>

集合和字典一样, 都属于无序的数据类型!<br>

集合的特点 (重要)
* 集合中不存在重复的元素
* 那么, 集合的其中一个很重要的作用就是**去重**了!

可变和不可变特性
* 集合本身是可变的, 也就是说集合中的元素可以被删除, 同时也可以往集合中添加新的元素
* 但是集合中的元素必须是不可变的, 也就是集合中的元素不能是列表和字典以及特殊的元组
* 至于修改元素, 这个功能对于集合来说不太适用, 因为集合中的元素既没有下标, 也没有像是字典那样的元素唯一标识(key), 也正是因为如此, 集合才会强制要求其中的元素是不可变的


解释一下什么叫特殊的元组, 元组本身不可变对吧, 看似很符合作为集合中元素的条件;<br>
但是如果元组中有一个列表呢? 比如: `my_set = {1, 2, "hello", (3, 4, [5, 6])}`<br>
这种情况下, 虽然(3, 4, [5, 6])本身不可变, 但是[5, 6]这个列表是能变的, 比如变成[7, 8];<br>
所以定义这样的非法集合是会报错的! <br>

集合的添加
1. set.add()
2. set.update() 
      * update这个方法的参数可以是可变对象, 它会把可变对象中的不可变元素提取出来
      * update添加的元素一定是最原子性的不可变对象 (拆到不能再拆)

集合的删除
1. set.remove()
      * 元素不存在, 直接报错
2. set.discard()
      * 元素不存在, 不会报错
3. set.pop()
      * 随机删除一个元素, 并把它返回出来

集合的大小

* len(set)

清空集合

* set.clear()

是否存在某个元素

* item in/not in set

**集合不需要也不能单独查某个元素**
**集合不需要count函数去统计出现次数因为集合中的元素只能出现1次**

**集合推导式**

`aset = {x for x in 可迭代对象 if 条件}`

集合的常用方法<br>

1. 减法算数运算 (集合独占)

相当于求补集

```python
aset = {1, 2, 3, 4, 5, 6}
bset = {2, 4, 6}
cset = aset - bset
print(cset)
```
结果
```
{1, 3, 5}
```

2. 集合运算 (类似于数学中集合的运算)

* 取并集 | (包含于集合a的所有元素 + 包含于集合b的所有元素)
```python
aset = {1, 2, 3}
bset = {4, 5, 6}
cset = aset | bset
print(cset)
```
结果<br>
```
{1, 2, 3, 4, 5, 6}
```
* 取交集 & (包含于集合a, 且同时包含于集合b)
```python
aset = {1, 2, 3, 4, 5}
bset = {1, 2}
cset = aset & bset
print(cset)
```
结果<br>
```
{1, 2}
```
* 补集的并集 ^ (不同时包含于集合a和集合b的元素)

首先理解一下补集是啥?<br>

补集 --> 补充用的集合<br>
谁对谁补充, 需要2个对象!<br>
比如: <br>
* A对B的补集, 就是B里没有但是A里有的元素组成的补充集合, 用A去补充B所需要的A中的部分元素
* B对A的补集, 就是A里没有但是B里有的元素组成的补充集合, 用B去补充A所需要的B中的部分元素

那么, 补集的并集就是 A对B的补充加上B对A的补充, 注意仅是补充的部分!

```python
aset = {1, 2, 3, 4, 5}
bset = {2, 4, 6, 8, 10}
cset = aset ^ bset
print(cset)
```
结果<br>
```
{1, 3, 5, 6, 8, 10}
# A对B的补集 {1, 3, 5}
# B对A的补集{6, 8, 10}
```
