I"p<h2>Tags</h2>
<ul>
    
    		<li>
		<a>
		<span>Sorting</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python选择排序</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python选择排序 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python选择排序" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="第一个数和它后面的所有数比较大小" />
<meta property="og:description" content="第一个数和它后面的所有数比较大小" />
<link rel="canonical" href="http://localhost:4000/Python%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" />
<meta property="og:url" content="http://localhost:4000/Python%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-26T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python选择排序" />
<script type="application/ld+json">
{"description":"第一个数和它后面的所有数比较大小","headline":"Python选择排序","dateModified":"2020-09-26T00:00:00+08:00","url":"http://localhost:4000/Python%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F","datePublished":"2020-09-26T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python选择排序</h2>
  <time datetime="2020-09-26T00:00:00+08:00" class="by-line">26 Sep 2020</time>
   
  <span>分类:<a>Algorithm</a></span>
  
   
  <span>标签:<a>Sorting</a></span>
  
  <p>第一个数和它后面的所有数比较大小<br /></p>

<blockquote>
  <p>两种情况:</p>
  <ol>
    <li>它就是最小的数, 那么保持原位置不动</li>
    <li>它不是最小的数, 那么让最小的数和它交换位置</li>
  </ol>
</blockquote>

<p>无论哪种情况出现, 结果都是最小的数排在第一位 <br />
<code class="language-plaintext highlighter-rouge">The Smallest Number Comes First</code><br />
紧接着<br />
第二个数和它后面的所有数比较大小<br />
结果把第二小的数排在第二位 <br />
<code class="language-plaintext highlighter-rouge">The Second Smallest Number Place In Second</code><br />
以此类推, 最终完成排序</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
    <span class="s">"""选择排序"""</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data_list</span><span class="p">[</span><span class="n">min_index</span><span class="p">]:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">min_index</span><span class="p">:</span>
            <span class="n">data_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">data_list</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">data_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">li</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">li</span><span class="p">)</span>
    <span class="n">select_sort</span><span class="p">(</span><span class="n">li</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">li</span><span class="p">)</span>
</code></pre></div></div>


</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python冒泡排序</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python冒泡排序 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python冒泡排序" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="冒泡排序,最小的元素像气泡一样逐渐上浮至水面; 从最后面开始,相邻比较,较小元素的放在较大的元素上面; 一轮之后最小的会跑到最上面,继续循环把次小的再排上来,直到整体有序." />
<meta property="og:description" content="冒泡排序,最小的元素像气泡一样逐渐上浮至水面; 从最后面开始,相邻比较,较小元素的放在较大的元素上面; 一轮之后最小的会跑到最上面,继续循环把次小的再排上来,直到整体有序." />
<link rel="canonical" href="http://localhost:4000/Python%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" />
<meta property="og:url" content="http://localhost:4000/Python%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-26T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python冒泡排序" />
<script type="application/ld+json">
{"description":"冒泡排序,最小的元素像气泡一样逐渐上浮至水面; 从最后面开始,相邻比较,较小元素的放在较大的元素上面; 一轮之后最小的会跑到最上面,继续循环把次小的再排上来,直到整体有序.","headline":"Python冒泡排序","dateModified":"2020-09-26T00:00:00+08:00","url":"http://localhost:4000/Python%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F","datePublished":"2020-09-26T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python冒泡排序</h2>
  <time datetime="2020-09-26T00:00:00+08:00" class="by-line">26 Sep 2020</time>
   
  <span>分类:<a>Algorithm</a></span>
  
   
  <span>标签:<a>Sorting</a></span>
  
  <p>冒泡排序,最小的元素像气泡一样逐渐上浮至水面;<br />
从最后面开始,相邻比较,较小元素的放在较大的元素上面;<br />
一轮之后最小的会跑到最上面,继续循环把次小的再排上来,直到整体有序.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort_1</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="c1"># 从后往前遍历索引
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 把最大的往后换并固定住,再找出剩余的数中最大的,以此类推
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">bubble_sort_2</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="c1"># 从前往后遍历索引
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 把最小的往前换并固定住,再找出剩余的数中最小的,以此类推
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
    <span class="n">bubble_sort_1</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>

    <span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
    <span class="n">bubble_sort_2</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

</code></pre></div></div>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>IP</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>IP地址详解</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>IP地址详解 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="IP地址详解" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="IP地址的作用 在网络中标识唯一主机" />
<meta property="og:description" content="IP地址的作用 在网络中标识唯一主机" />
<link rel="canonical" href="http://localhost:4000/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3" />
<meta property="og:url" content="http://localhost:4000/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="IP地址详解" />
<script type="application/ld+json">
{"description":"IP地址的作用 在网络中标识唯一主机","headline":"IP地址详解","dateModified":"2020-09-27T00:00:00+08:00","url":"http://localhost:4000/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3","datePublished":"2020-09-27T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>IP地址详解</h2>
  <time datetime="2020-09-27T00:00:00+08:00" class="by-line">27 Sep 2020</time>
   
  <span>分类:<a>Network</a></span>
  
   
  <span>标签:<a>IP</a></span>
  
  <h3 id="ip地址的作用">IP地址的作用</h3>
<blockquote>
  <p>在网络中标识唯一主机</p>
</blockquote>

<h3 id="ip地址的构成">IP地址的构成</h3>
<blockquote>
  <p>32位<br />
X.X.X.X 四个8位二进制数的组合<br />
举例: 11000011.00000000.00000000.11010010</p>
</blockquote>

<h3 id="ip地址的一般表示">IP地址的一般表示</h3>
<blockquote>
  <p>点分十进制  A.B.C.D<br />
数字范围: 0~255<br />
IP地址范围: 0.0.0.0 ~ 255.255.255.255</p>
</blockquote>

<h3 id="ip地址的分解">IP地址的分解</h3>
<blockquote>
  <p>IP地址总共4段组成<br />
可以分解为<strong>网络位</strong>和<strong>主机位</strong>两个部分</p>
</blockquote>

<h3 id="网络位和主机位">网络位和主机位</h3>
<blockquote>
  <p>网络位和主机位此消彼长<br /></p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>假设: IP地址为 A.B.C.D
if 网络位 == A.B.C:
	主机位 == D
elif 网络位 == A.B:
	主机位 == C.D
elif 网络位 == A:
	主机位 == B.C.D
# 注意: 网络位永远不包含D段, 而主机位则永远不包含A段
</code></pre></div>  </div>
  <p>判断网络位和主机位的依据: <strong>子网掩码</strong><br />
注意: 主机位不能全为0 也不能全为255</p>
</blockquote>

<h3 id="子网掩码">子网掩码</h3>
<blockquote>
  <p>子网掩码是从IP地址中剥离出来的功能性地址<br />
子网掩码永远和IP<strong>一起出现</strong>, 二者不可分开使用<br />
子网掩码的<strong>作用</strong>: 用来判断IP地址网络位和主机位<br />
子网掩码一共三种: <br /></p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>255.0.0.0	代表: 网络位是A段        主机位是B.C.D段
255.255.0.0	代表: 网络位是A.B段      主机位是C.D段
255.255.255.0	代表: 网络位是A.B.C段    主机位是D段
</code></pre></div>  </div>
  <p>掩码的简写 /8 /16 /24</p>
</blockquote>

<h3 id="网段地址">网段地址</h3>
<blockquote>
  <p>IP地址的主机位全为0的叫网段地址<br />
局域网的通信规则: 在局域网<strong>同一个网段</strong>的主机才可以通信<br />
也就是主机的网段地址相同</p>
</blockquote>

<h3 id="广播地址">广播地址</h3>
<blockquote>
  <p>IP地址的主机位全为255的叫广播地址</p>
</blockquote>

<h3 id="iso定义的ip地址分类">ISO定义的IP地址分类</h3>
<blockquote>
  <p>五大类A-E(以IP地址的<strong>第一位</strong>进行区分)<br /></p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A类: 1-126 	默认子网掩码 255.0.0.0
B类: 128-191 	默认子网掩码 255.255.0.0
C类: 192-223 	默认子网掩码 255.255.255.0
D类: 224-239 	组播地址
E类: 240-254 	科研使用
不在5大类的: 0 127 255
</code></pre></div>  </div>
  <p>默认子网掩码规则不需要严格遵守</p>
</blockquote>

<h3 id="127地址">127地址</h3>
<blockquote>
  <p>127.0.0.1 本机回环地址</p>
</blockquote>

<h3 id="全局广播地址">全局广播地址:</h3>
<blockquote>
  <p>255.255.255.255</p>
</blockquote>

<h3 id="网关">网关</h3>
<blockquote>
  <p>内网的出口 GateWay==GW<br />
一般网关在路由器上<br />
网关也是IP地址<br />
一般是该网段的第一个或最后一个IP地址</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X.X.X.1  X.X.X.254
</code></pre></div>  </div>
</blockquote>

<h3 id="个人主机的ip地址">个人主机的IP地址</h3>
<blockquote>
  <p>主机位可以有0 和 255 出现, 但不能全是0 或者 全是255</p>
</blockquote>

<h3 id="例题1">例题1</h3>
<blockquote>
  <p>IP 10.1.1.1 掩码255.255.255.0 问IP在哪个网段?<br />
<code class="language-plaintext highlighter-rouge">10.1.1.0  (网段名称)</code><br />
所在网段有多少个可用的IP地址?<br />
<code class="language-plaintext highlighter-rouge">从1-254 一共254个可用 (0和255除外)</code><br />
该网段的广播地址是什么?<br />
<code class="language-plaintext highlighter-rouge">10.1.1.255  (网段里的所有人)&lt;br&gt;</code></p>
</blockquote>

<h3 id="例题2">例题2</h3>
<blockquote>
  <p>IP 10.1.1.1 掩码 255.255.0.0 问IP在哪个网段?<br />
<code class="language-plaintext highlighter-rouge">10.1.0.0</code><br />
该网段一共有多少个可用IP<br />
<code class="language-plaintext highlighter-rouge">65534 </code><br />
<code class="language-plaintext highlighter-rouge">10.1.0.1 ~ 10.1.255.254 </code><br />
该网段的广播地址是什么?<br />
<code class="language-plaintext highlighter-rouge">10.1.255.255</code><br /></p>
</blockquote>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Command</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Linux命令行常用符号</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Linux命令行常用符号 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Linux命令行常用符号" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="输入输出重定向 | | 文件描述符 | 默认 | | :————: | :——–: | :——-: | | 标准输入重定向 | 0 | 键盘/文件 | | 标准输出重定向 | 1 | 屏幕 | | 错误输出重定向 | 2 | 屏幕 | 输入重定向 命令 &lt; 文件 把文件当作命令的标准输入 命令 « 分界符 从标准输入中读入, 直到碰见分界符停止 命令 &lt; 文件A &gt; 文件B 将文件A作为命令的标准输入并把标准输出到文件B 文件描述符 &lt;&amp; 文件描述符 从文件描述符中输入重定向到另一个文件描述符 (举例: 1 &lt;&amp; 100)" />
<meta property="og:description" content="输入输出重定向 | | 文件描述符 | 默认 | | :————: | :——–: | :——-: | | 标准输入重定向 | 0 | 键盘/文件 | | 标准输出重定向 | 1 | 屏幕 | | 错误输出重定向 | 2 | 屏幕 | 输入重定向 命令 &lt; 文件 把文件当作命令的标准输入 命令 « 分界符 从标准输入中读入, 直到碰见分界符停止 命令 &lt; 文件A &gt; 文件B 将文件A作为命令的标准输入并把标准输出到文件B 文件描述符 &lt;&amp; 文件描述符 从文件描述符中输入重定向到另一个文件描述符 (举例: 1 &lt;&amp; 100)" />
<link rel="canonical" href="http://localhost:4000/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7" />
<meta property="og:url" content="http://localhost:4000/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-05T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Linux命令行常用符号" />
<script type="application/ld+json">
{"description":"输入输出重定向 | | 文件描述符 | 默认 | | :————: | :——–: | :——-: | | 标准输入重定向 | 0 | 键盘/文件 | | 标准输出重定向 | 1 | 屏幕 | | 错误输出重定向 | 2 | 屏幕 | 输入重定向 命令 &lt; 文件 把文件当作命令的标准输入 命令 « 分界符 从标准输入中读入, 直到碰见分界符停止 命令 &lt; 文件A &gt; 文件B 将文件A作为命令的标准输入并把标准输出到文件B 文件描述符 &lt;&amp; 文件描述符 从文件描述符中输入重定向到另一个文件描述符 (举例: 1 &lt;&amp; 100)","headline":"Linux命令行常用符号","dateModified":"2020-10-05T00:00:00+08:00","url":"http://localhost:4000/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7","datePublished":"2020-10-05T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Linux命令行常用符号</h2>
  <time datetime="2020-10-05T00:00:00+08:00" class="by-line">05 Oct 2020</time>
   
  <span>分类:<a>Linux</a></span>
  
   
  <span>标签:<a>Command</a></span>
  
  <h3 id="输入输出重定向">输入输出重定向</h3>
<p>|                | 文件描述符 |   默认    |
| :————: | :——–: | :——-: |
| 标准输入重定向 |     0      | 键盘/文件 |
| 标准输出重定向 |     1      |   屏幕    |
| 错误输出重定向 |     2      |   屏幕    |
<strong>输入重定向</strong></p>
<ul>
  <li>命令 &lt; 文件   把文件当作命令的标准输入</li>
  <li>命令 « 分界符   从标准输入中读入, 直到碰见分界符停止</li>
  <li>命令 &lt; 文件A &gt; 文件B   将文件A作为命令的标准输入并把标准输出到文件B</li>
  <li>文件描述符 &lt;&amp; 文件描述符  从文件描述符中输入重定向到另一个文件描述符 (举例: 1 &lt;&amp; 100)</li>
</ul>

<p><strong>输出重定向</strong></p>
<ul>
  <li>&gt; 覆盖式</li>
  <li>&gt;&gt; 追加式</li>
  <li>命令 2» 文件   输出默认是标准输出, 想操作错误输出需要在命令后面加上描述符2</li>
  <li>命令 &amp;» 文件   把标准和错误输出同时重定向到文件中</li>
  <li>文件描述符 &gt;&amp; 文件描述符  输出重定向到另一个文件描述符(举例: 1 &gt;&amp; 101)
    <h3 id="管道符号">管道符号</h3>
  </li>
  <li>命令A|命令B  把命令A的标准输出作为命令B的标准输入, 而不是直接输出在屏幕上
    <h3 id="通配符">通配符</h3>
  </li>
  <li>*号–所有</li>
  <li>?号–1个
    <h3 id="转义符号">转义符号</h3>
  </li>
  <li>反斜杠\        后面的变量转义成纯字符</li>
  <li>单引号’’       把其中所有变量转义成纯字符</li>
  <li>双引号””       保留其中的变量属性, 不转义</li>
  <li>反引号``       把其中的命令执行后返回结果(只需要命令执行后的结果)</li>
</ul>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Linux系统中的压缩和打包</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Linux系统中的压缩和打包 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Linux系统中的压缩和打包" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="首先要区分压缩和打包 压缩是把大文件压成小文件, 最终结果是大变小 打包是把多个文件和目录装在一个文件里头, 最终结果是多变一" />
<meta property="og:description" content="首先要区分压缩和打包 压缩是把大文件压成小文件, 最终结果是大变小 打包是把多个文件和目录装在一个文件里头, 最终结果是多变一" />
<link rel="canonical" href="http://localhost:4000/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%89%93%E5%8C%85" />
<meta property="og:url" content="http://localhost:4000/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%89%93%E5%8C%85" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Linux系统中的压缩和打包" />
<script type="application/ld+json">
{"description":"首先要区分压缩和打包 压缩是把大文件压成小文件, 最终结果是大变小 打包是把多个文件和目录装在一个文件里头, 最终结果是多变一","headline":"Linux系统中的压缩和打包","dateModified":"2020-09-27T00:00:00+08:00","url":"http://localhost:4000/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%89%93%E5%8C%85","datePublished":"2020-09-27T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%89%93%E5%8C%85"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Linux系统中的压缩和打包</h2>
  <time datetime="2020-09-27T00:00:00+08:00" class="by-line">27 Sep 2020</time>
   
  <span>分类:<a>Linux</a></span>
  
   
  <span>标签:<a>Command</a></span>
  
  <h3 id="首先要区分压缩和打包">首先要区分压缩和打包</h3>
<ul>
  <li>压缩是把大文件压成小文件, 最终结果是大变小</li>
  <li>打包是把多个文件和目录装在一个文件里头, 最终结果是多变一</li>
</ul>

<blockquote>
  <p>在Linux系统中目前常用的压缩格式是 gzip 和 bzip2 两种
而在Linux系统中目前常用的打包格式是 tar 一种</p>
</blockquote>

<h3 id="压缩">压缩</h3>
<p>压缩的对象一定要是一个<strong>文件</strong>而不能是目录!!!<br />
它可以压缩<code class="language-plaintext highlighter-rouge">.py</code> <code class="language-plaintext highlighter-rouge">.txt</code> 等类型的单个文件, 也可以压缩 <code class="language-plaintext highlighter-rouge">.tar</code> 的打包后的文件<br /></p>

<p><em>压缩命令</em><br />
<code class="language-plaintext highlighter-rouge">gzip 文件名</code><br /></p>

<p><code class="language-plaintext highlighter-rouge">bzip2 文件名</code>  <br /></p>

<p><em>解压命令</em><br />
<code class="language-plaintext highlighter-rouge">gunzip 压缩包名</code><br /></p>

<p><code class="language-plaintext highlighter-rouge">bunzip2 压缩包名</code> <br /></p>

<h3 id="打包">打包</h3>
<p>正是因为压缩只能针对文件, 所以打包就派上用场了!!!<br />
不能直接压缩目录, 必须先打包<br /></p>

<p><em>打包命令</em><br />
<code class="language-plaintext highlighter-rouge">tar -cf 目标路径 源路径</code>     不会影响源目录, 而是生成一个新的打包文件<br /></p>

<p>c f – create file <br /></p>

<p><em>列出打包文件信息</em><br />
<code class="language-plaintext highlighter-rouge">tar -tvf 打包文件名</code>     查看打包文件中的所有文件信息<br /></p>

<p>t v f – list verbose file <br /></p>

<p><em>拆包命令</em> <br />
<code class="language-plaintext highlighter-rouge">tar -xf 打包文件</code>     在当前路径下拆包 <br /></p>

<p><code class="language-plaintext highlighter-rouge">tar -xf 打包文件 -C 指定路径</code>     在指定的路径下拆包 <br /></p>

<p>x f – extract file <br />
C – change to directory <br /></p>

<h3 id="压缩目录多文件">压缩目录(多文件)</h3>
<blockquote>
  <p>两种方式</p>
  <ol>
    <li>先打包后压缩</li>
    <li>打包的同时压缩</li>
  </ol>
</blockquote>

<p><em>先打包后压缩</em><br />
命令分两步 先做tar命令打包目录 再做gzip/bzip2压缩命令压缩打包文件<br /></p>

<p><em>先解压后拆包</em><br />
逆过程则相反 先做gunzip或者bunzip2解压 再做tar命令拆包<br /></p>

<p><em>打包的同时压缩</em><br />
<code class="language-plaintext highlighter-rouge">tar -zcf 目标路径  源路径</code>     tar打包后, 用gzip格式压缩打包文件<br /></p>

<p><code class="language-plaintext highlighter-rouge">tar -jcf 目标路径  源路径 </code>     tar打包后, 用bzip2格式压缩打包文件<br /></p>

<p>加 <code class="language-plaintext highlighter-rouge">-v</code>  查看信息<br /></p>

<p><em>解压缩同时拆包</em><br />
<code class="language-plaintext highlighter-rouge">tar -zxf 压缩文件 -C 指定路径</code>    用gzip格式解压缩, 在指定路径下拆包<br /></p>

<p><code class="language-plaintext highlighter-rouge">tar -jxf 压缩文件 -C 指定路径</code>    用bzip2格式解压缩, 在指定路径下拆包<br /></p>

<p>加 <code class="language-plaintext highlighter-rouge">-v</code>  查看信息<br /></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Range</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>SQLI-LABS靶场环境搭建详细流程</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>SQLI-LABS靶场环境搭建详细流程 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="SQLI-LABS靶场环境搭建详细流程" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="准备工作 需要虚拟机一台: 我用的是Win2008R2企业版 Web容器: phpstudy2016 额外需要安装VC9_x86 32位 为了配合phpstudy2016版本中版本较低的php环境, 所以需要提前安装好32位的VC9 靶场直接从github上下载zip包即可 sqli-labs 的github地址:[https://github.com/Audi-1/sqli-labs]" />
<meta property="og:description" content="准备工作 需要虚拟机一台: 我用的是Win2008R2企业版 Web容器: phpstudy2016 额外需要安装VC9_x86 32位 为了配合phpstudy2016版本中版本较低的php环境, 所以需要提前安装好32位的VC9 靶场直接从github上下载zip包即可 sqli-labs 的github地址:[https://github.com/Audi-1/sqli-labs]" />
<link rel="canonical" href="http://localhost:4000/SQLI-LABS%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B" />
<meta property="og:url" content="http://localhost:4000/SQLI-LABS%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-10T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SQLI-LABS靶场环境搭建详细流程" />
<script type="application/ld+json">
{"description":"准备工作 需要虚拟机一台: 我用的是Win2008R2企业版 Web容器: phpstudy2016 额外需要安装VC9_x86 32位 为了配合phpstudy2016版本中版本较低的php环境, 所以需要提前安装好32位的VC9 靶场直接从github上下载zip包即可 sqli-labs 的github地址:[https://github.com/Audi-1/sqli-labs]","headline":"SQLI-LABS靶场环境搭建详细流程","dateModified":"2020-10-10T00:00:00+08:00","url":"http://localhost:4000/SQLI-LABS%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B","datePublished":"2020-10-10T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/SQLI-LABS%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>SQLI-LABS靶场环境搭建详细流程</h2>
  <time datetime="2020-10-10T00:00:00+08:00" class="by-line">10 Oct 2020</time>
   
  <span>分类:<a>PenTest</a></span>
  
   
  <span>标签:<a>Range</a></span>
  
  <blockquote>
  <p>准备工作<br /></p>
  <ul>
    <li>需要虚拟机一台: 我用的是Win2008R2企业版<br /></li>
    <li>Web容器: phpstudy2016  <br />
  额外需要安装VC9_x86 32位 为了配合phpstudy2016版本中版本较低的php环境, 所以需要提前安装好32位的VC9<br /></li>
    <li>靶场直接从github上下载zip包即可 sqli-labs 的github地址:[https://github.com/Audi-1/sqli-labs]</li>
  </ul>
</blockquote>

<h3 id="第一步-安装vc9-32位--解压安装phpstudy2016">第一步: 安装VC9 32位 + 解压安装phpstudy2016</h3>
<p>我的安装目录是在D盘<br />
安装完毕后测试一下端口是否开启</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat -an  # 看一下tcp 80 和 3306 是否开启监听
</code></pre></div></div>
<h3 id="第二步-把解压好的靶场目录丢到web服务目录中">第二步: 把解压好的靶场目录丢到Web服务目录中</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>我的目录是 D:\phpStudy\WWW
</code></pre></div></div>
<h3 id="第三部-允许目录列表--修改数据库配置文件">第三部: 允许目录列表 + 修改数据库配置文件</h3>
<p>访问目标IP不想显示探针, 而是直接显示目录, 可以在右下托盘中点击phpstudy, phpstudy设置–&gt;允许目录列表 给勾上<br />
默认的数据库配置文件只有用户名 root 而没有密码, 所以我们要找到配置文件, 把弱口令 root 填写进去<br />
配置文件的路径 <code class="language-plaintext highlighter-rouge">D:\phpStudy\WWW\sqli-labs-master\sql-connections\db-creds.inc</code>
修改的配置 <code class="language-plaintext highlighter-rouge">$dbpass ='root'</code></p>

<p><strong>以上就是搭建SQLI-LABS靶场的详细过程, 开始练习吧</strong></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Vulhub靶场环境搭建</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Vulhub靶场环境搭建 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Vulhub靶场环境搭建" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="需要准备: Ubuntu16.04虚拟机一部 Vulhub源码zip压缩包(github直接下载)" />
<meta property="og:description" content="需要准备: Ubuntu16.04虚拟机一部 Vulhub源码zip压缩包(github直接下载)" />
<link rel="canonical" href="http://localhost:4000/Vulhub%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" />
<meta property="og:url" content="http://localhost:4000/Vulhub%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-08T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Vulhub靶场环境搭建" />
<script type="application/ld+json">
{"description":"需要准备: Ubuntu16.04虚拟机一部 Vulhub源码zip压缩包(github直接下载)","headline":"Vulhub靶场环境搭建","dateModified":"2020-10-08T00:00:00+08:00","url":"http://localhost:4000/Vulhub%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA","datePublished":"2020-10-08T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Vulhub%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Vulhub靶场环境搭建</h2>
  <time datetime="2020-10-08T00:00:00+08:00" class="by-line">08 Oct 2020</time>
   
  <span>分类:<a>PenTest</a></span>
  
   
  <span>标签:<a>Range</a></span>
  
  <blockquote>
  <p>需要准备:</p>
  <ol>
    <li>Ubuntu16.04虚拟机一部</li>
    <li>Vulhub源码zip压缩包(github直接下载)</li>
  </ol>
</blockquote>

<ul>
  <li>强烈建议在做好每一个步骤时都 <code class="language-plaintext highlighter-rouge">poweroff</code> 一下, 做一个快照, 以备不时之需!!!</li>
</ul>

<h3 id="第一步-更换apt软件源--安装ssh服务--关闭dnsmq服务port53">第一步: 更换apt软件源 + 安装ssh服务 + 关闭dnsmq服务(port:53)</h3>

<blockquote>
  <p>主要目的:</p>
  <ol>
    <li>换成国内软件源就不用多说了, 保证软件能正常快速地更新和下载</li>
    <li>ssh远程登录管理, 方便快捷, 只需要虚拟机开机即可 (Ubuntu的图形界面多少会降低性能)</li>
    <li>关闭dnsmq服务, 释放53端口, 测试过程中可能会需要用到53端口, 提前关闭可能占用的服务以免影响实验</li>
  </ol>
</blockquote>

<ul>
  <li>首先, 更换源
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 备份原始文件
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
# 给文件赋权
sudo chmod 777 /etc/apt/sources.list
# 修改文件内容
清空文件, 然后参考清华源的文档复制粘贴
[https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/]
选择Ubuntu16.04LTS
sudo vi /etc/apt/sources.list
完整拷贝即可, 然后 :wq 保存退出
</code></pre></div>    </div>
  </li>
  <li>更新一下软件源列表 <code class="language-plaintext highlighter-rouge">sudo apt update</code></li>
  <li>然后安装ssh服务 <code class="language-plaintext highlighter-rouge">sudo apt-get install ssh</code></li>
  <li>更改sshd的配置文件 <code class="language-plaintext highlighter-rouge">vi /etc/ssh/sshd_config</code>  第28, 52行 开启 yes
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 允许远程ROOT用户登录
PermitRootLogin prohibit-password 改成 PermitRootLogin yes
# 需要密码认证
PasswordAuthentication yes 注释开启
</code></pre></div>    </div>
  </li>
  <li>启动ssh服务 <code class="language-plaintext highlighter-rouge">service ssh start</code></li>
  <li>验证一下 <code class="language-plaintext highlighter-rouge">ss -antpl | grep ssh</code> 或者 <code class="language-plaintext highlighter-rouge">ps -aux | grep ssh</code></li>
  <li>
    <p>添加到开机自启动 <code class="language-plaintext highlighter-rouge">update-rc.d ssh enable</code></p>
  </li>
  <li>此时已经可以用Putty连接到Ubuntu了</li>
  <li>关闭53端口的服务 dnsmq (dns缓存)</li>
  <li>先备份配置文件 /etc/NetworkManger/NetworkManger.conf
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /etc/NetworkManger
sudo cp NetworkManger.conf NetworkManger.conf.bak
</code></pre></div>    </div>
  </li>
  <li>注释掉关键行
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># dns=dnsmq
</code></pre></div>    </div>
  </li>
  <li>重启计算机
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reboot
</code></pre></div>    </div>
  </li>
  <li>用Putty重新建立ssh连接</li>
</ul>

<h3 id="第二步-安装docker--安装python和pip--用pip安装docker-compose包">第二步: 安装Docker + 安装Python和pip + 用pip安装docker-compose包<br /></h3>
<ol>
  <li>首先, 安装docker<br />
Vulhub的官网推荐直接拉取<br />
curl -s https://get.docker.com/ | sh   (这里不建议直接执行)<br />
    <ul>
      <li>建议先打开链接, 把文本复制存成 <code class="language-plaintext highlighter-rouge">.sh</code>文件后, 在虚拟机本地执行
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo vi installDocker.sh
复制粘贴 :wq 保存退出
</code></pre></div>        </div>
      </li>
      <li>添加可执行权限后执行安装docker
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x installDocker.sh
./installDocker.sh
</code></pre></div>        </div>
      </li>
      <li>测试安装
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker 
docker -v
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>安装docker-compose(快速启动器)
    <ul>
      <li>最好提前修改一下pip源(网上有很多教程和源, 参考即可, 不展开)
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install python-pip
更换pip源
pip install docker-compose
</code></pre></div>        </div>
      </li>
      <li>注意此处如果安装报错, 可能是pip版本太低导致
执行 <code class="language-plaintext highlighter-rouge">sudo pip install --upgrade pip</code>后再次尝试安装, 大概率安装成功(具体看报错类型, 不绝对)</li>
      <li>测试安装
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose
docker-compose -v
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h3 id="第三步-下载源码zip包并放入虚拟机--直接解压zip包--启动vulhub环境">第三步: 下载源码zip包并放入虚拟机 + 直接解压zip包 + 启动vulhub环境</h3>

<ol>
  <li>下载源码zip并放到虚拟机中
    <ul>
      <li>很多方法啦, 我用的是filezilla直接上传的</li>
      <li>下载地址 [https://github.com/vulhub/vulhub.git]</li>
      <li>解压缩 <code class="language-plaintext highlighter-rouge">unzip vulhub-master.zip</code></li>
    </ul>
  </li>
  <li>启动环境
    <ul>
      <li>cd到vulhub-master目录下</li>
      <li>找到漏洞环境对应的目录</li>
      <li>执行sudo</li>
      <li>此时会从网络上拉取镜像到虚拟机本地, 再启动环境
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker-compose build
sudo docker-compose up -d
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>测试完成删除环境
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker-compose down
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>到此, Vulhub漏洞靶场环境搭建完毕, 需要实验时开启虚拟机, ssh客户端连接, 启动vulhub环境, 参考官网测试方案即可开始练习</strong></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>OOP</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python面向对象问答收集</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python面向对象问答收集 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python面向对象问答收集" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="面向对象Q&amp;A" />
<meta property="og:description" content="面向对象Q&amp;A" />
<link rel="canonical" href="http://localhost:4000/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%97%AE%E7%AD%94%E6%94%B6%E9%9B%86" />
<meta property="og:url" content="http://localhost:4000/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%97%AE%E7%AD%94%E6%94%B6%E9%9B%86" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-09T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python面向对象问答收集" />
<script type="application/ld+json">
{"description":"面向对象Q&amp;A","headline":"Python面向对象问答收集","dateModified":"2020-10-09T00:00:00+08:00","url":"http://localhost:4000/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%97%AE%E7%AD%94%E6%94%B6%E9%9B%86","datePublished":"2020-10-09T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%97%AE%E7%AD%94%E6%94%B6%E9%9B%86"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python面向对象问答收集</h2>
  <time datetime="2020-10-09T00:00:00+08:00" class="by-line">09 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>OOP</a></span>
  
  <h2 id="面向对象qa">面向对象Q&amp;A</h2>

<h3 id="1-问-为什么类的私有属性例如__name从外部不能直接访问">1. 问: 为什么类的私有属性(例如:__name),从外部不能直接访问?</h3>

<p>答: 因为实例化以后会改变私有属性的名称, 变成 “__类名__私有属性”, 所以不能用原来的私有属性直接访问;另外也并不建议使用”__类名__私有属性”去强行访问,因为不同版本的解释器有可能会把私有属性改成不同的属性名!</p>

<h3 id="2-问-一个类中的单下划线属性例如-_age是私有属性吗">2. 问: 一个类中的单下划线属性(例如: _age)是私有属性吗?</h3>

<p>答: 其实单下划线开头的属性并不是私有属性,但是约定俗称的视为私有, 所以即使可以从外部直接访问,但是不建议</p>

<h3 id="3-问-类里面前后都有双下划线的属性例如__name__是啥能直接访问吗">3. 问: 类里面前后都有双下划线的属性(例如:__name__)是啥,能直接访问吗?</h3>

<p>答: 是特殊属性, 可以直接从外部访问, 但是因为本身有特殊用途的属性才这样命名,所以一般我们定义的属性不能使用这种方式命名!</p>

<h3 id="4-问-私有属性不能从外部访问-那如果就想访问怎么办呢">4. 问: 私有属性不能从外部访问, 那如果就想访问怎么办呢?</h3>

<p>答: 可以定义获取私有属性的方法, 把私有属性给return出来</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">__name</span>


<span class="n">stu</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="s">"laowang"</span><span class="p">)</span>
<span class="n">stu</span><span class="p">.</span><span class="n">get_name</span><span class="p">()</span>  <span class="c1"># 调用方法获取私有属性
</span></code></pre></div></div>

<h3 id="5-问-不仅想从外部访问私有属性-还想修改私有属性怎么办">5. 问: 不仅想从外部访问私有属性, 还想修改私有属性,怎么办?</h3>

<p>答: 还是可以定义一个修改私有属性的方法,通过调用方法去修改私有属性的值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
        
<span class="n">stu</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"xiaowang"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="6-问--如果从外部动态的修改私有属性能修改成功吗">6. 问 : 如果从外部动态的修改私有属性,能修改成功吗?</h3>

<p>答: 首先从外部动态绑定的属性, 即使前缀是双下划线, 甚至和原来的私有属性同名, 它都不会是一个私有属性, 而是一个新的普通实例属性, 可以从外部直接访问;而且私有属性在实例化以后其实已经不再是原来的名字了(新的名字不容易推断,会根据解释器不同而改变), 所以仅和类中定义的私有属性同名是无法修改私有属性的</p>

<h3 id="7-问-私有属性干什么用的">7. 问: 私有属性干什么用的?</h3>

<p>答: 限制访问用的, 当你不想让外部代码随意改变对象的内部状态时, 就可以使用私有属性(私有变量)把内部变量保护起来</p>

<h3 id="8-问-啥是基类啥是父类啥又是超类">8. 问: 啥是基类?啥是父类?啥又是超类?</h3>

<p>答: 基类 父类 超类 本身就是同一个概念, 都是指面向对象继承中被继承的一方!</p>

<h3 id="9-问-多态是啥东西">9: 问: 多态是啥东西?</h3>

<p>答: 我们在定义类class时, 其实就是定义了一个数据类型, 那么实例后的对象自然就属于这个类型; 又因为有继承的存在, 那么实例对象既是当前类的数据类型,又是父类的数据类型, 反之则不行!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Animal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">is_animal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"is animal"</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">is_dog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"is dog"</span><span class="p">)</span>


<span class="n">xb</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xb</span><span class="p">,</span> <span class="n">Dog</span><span class="p">))</span>  <span class="c1"># True
</span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xb</span><span class="p">,</span> <span class="n">Animal</span><span class="p">))</span>  <span class="c1"># True 是狗一定是动物
</span>
<span class="n">dh</span> <span class="o">=</span> <span class="n">Animal</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">Animal</span><span class="p">))</span>  <span class="c1"># True
</span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">Dog</span><span class="p">))</span>  <span class="c1"># False 是动物但不一定是狗
</span></code></pre></div></div>

<h3 id="10-问-多态有啥好处">10. 问: 多态有啥好处?</h3>

<p>答: 继承自统一个父类的所有子类, 如果都有一个同名方法, 那么如果公共方法正好调用对象的这个同名方法时, 在传入不同实例的情况下会自动调用对应的方法, 而不用修改公共方法本身!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_once</span><span class="p">(</span><span class="n">animal</span><span class="p">):</span>
    <span class="n">animal</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
    

<span class="k">class</span> <span class="nc">Animal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Animal is running..."</span><span class="p">)</span>
        

<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Dog is running..."</span><span class="p">)</span>
        

<span class="k">class</span> <span class="nc">Cat</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Cat is running..."</span><span class="p">)</span>

     
<span class="n">run_once</span><span class="p">(</span><span class="n">Animal</span><span class="p">())</span>  <span class="c1"># "Animal is running..."
</span><span class="n">run_once</span><span class="p">(</span><span class="n">Dog</span><span class="p">())</span>  <span class="c1"># "Dog is running..."
</span><span class="n">run_once</span><span class="p">(</span><span class="n">Cat</span><span class="p">())</span>  <span class="c1"># "Cat is running..."
</span></code></pre></div></div>

<h3 id="11-问-啥是鸭子类型">11. 问: 啥是鸭子类型?</h3>

<p>答:  对于静态语言（例如Java）来说，如果需要传入<code class="language-plaintext highlighter-rouge">Animal</code>类型，则传入的对象必须是<code class="language-plaintext highlighter-rouge">Animal</code>类型或者它的子类，否则，将无法调用<code class="language-plaintext highlighter-rouge">run()</code>方法。对于Python这样的动态语言来说，则不一定需要传入<code class="language-plaintext highlighter-rouge">Animal</code>类型。我们只需要保证传入的对象有一个<code class="language-plaintext highlighter-rouge">run()</code>方法就可以了;这就是动态语言的“鸭子类型”，它并不要求严格的继承体系</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Duck</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># Duck继承自object类,并没继承自Animal类
</span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Duck is running..."</span><span class="p">)</span>
        
<span class="n">run_once</span><span class="p">(</span><span class="n">Duck</span><span class="p">())</span>  <span class="c1"># "Duck is running..."  既使不继承自Animal依然可以调用     
</span></code></pre></div></div>

<h3 id="12-问-可以给类动态地绑定方法吗">12. 问: 可以给类动态地绑定方法吗?</h3>

<p>答: 可以, 直接在外部使用 “类名.方法名 = 方法”即可</p>

<h3 id="13-问-想要限制从外部添加的实例属性-怎么做">13. 问: 想要限制从外部添加的实例属性, 怎么做?</h3>

<p>答:在类的内部, 使用特殊变量__slots__=(“ “, “  “, …)去限定能够添加的属性名, 试图从外部添加限定外的属性时, 会报错</p>

<h3 id="14-问-__slots__定义的限制属性对子类实例起作用吗">14. 问: __slots__定义的限制属性对子类实例起作用吗?</h3>

<p>答: __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的;</p>

<h3 id="15-问-如果父类定义了-__slots__-子类中又定义了-__slots__会怎么样">15. 问: 如果父类定义了 __slots__, 子类中又定义了 __slots__会怎么样?</h3>

<p>答: 此时, 子类实例限制添加的属性就等于”父类限制+子类限制”, 也就是如果子类也定义 __slots__则自动继承父类的 __slots__</p>

<h3 id="16-问-为什么需要property装饰器呢">16. 问: 为什么需要@property装饰器呢?</h3>

<p>答: 直接使用外部添加、修改、访问的方式去操作属性, 太暴露且不能定义参数检验, 容易导致属性被胡乱修改; 而在类的内部对一个属性定义多个操作函数又略显杂乱, 所以此时就需要@property装饰器把函数当属性用</p>

<h3 id="17-问--property装饰器的好处是啥">17. 问 : @property装饰器的好处是啥?</h3>

<p>答: 可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性</p>

<h3 id="18-问-怎么使用property装饰器呢">18. 问: 怎么使用@property装饰器呢?</h3>

<p>答: 首先在获取属性的方法加上@property装饰器, 然后在设置(修改)属性的方法上面加上@属性名.setter的装饰器, 如果是只读属性就在读方法上面加一个@property装饰器即可</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># birth的读方法
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_birth</span>

    <span class="o">@</span><span class="n">birth</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>  <span class="c1"># birth的写方法
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_birth</span> <span class="o">=</span> <span class="n">value</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 只读属性
</span>        <span class="k">return</span> <span class="mi">2015</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">_birth</span>
</code></pre></div></div>

<h3 id="19-问-怎么理解mixin">19. 问: 怎么理解Mixin?</h3>

<p>答: 多继承中,非主线继承的类, 为了增加混入的其他功能的类在命名时一般会加上Mixin以作区别;通过直接继承Mixin类,可以避免设计过于复杂的继承路线, 使类的层级结构更清晰</p>

<h3 id="20-问-__str__和__repr__分别是干嘛用的">20. 问: __str__和__repr__分别是干嘛用的?</h3>

<p>答: 都是可以自定义输出格式的方法; __str__主要面向用户, 而 __repr__主要是给程序员看的, 使用print()方法打印对象, 才会调用 __str__, 如果直接显示变量(例如在控制台)则会调用 __repr__; 偷懒的定义方法, 只定义一个__str__,然后 __repr__ = __str__即可统一输出格式</p>

<h3 id="21-问-__iter__干嘛用的__next__又是干嘛用的">21. 问: __iter__()干嘛用的?__next__()又是干嘛用的?</h3>

<p>答: 如果一个类想要用于for in 循环, 则必须实现一个__iter__()方法, 返回一个可迭代对象, 也就是实例本身self ; for循环就会不断地调用实例的__next__()方法拿到循环的下一个值, 直到StopIteration</p>

<h3 id="22-问-一个可迭代的实例对象-想要使用下标和切片访问-怎么实现">22. 问: 一个可迭代的实例对象, 想要使用下标和切片访问, 怎么实现?</h3>

<p>答: 使用__getitem__()方法实现, 注意需要判断传入的参数是int还是slice类型, 以区别下标访问和切片访问; 但是这里的切片不能对step参数处理, 也就是不能自定义步长, 同时也不能使用复数</p>

<h3 id="23-问-除了__getitem__以外-__setitem__和__delitem__又是干嘛用的">23. 问: 除了__getitem__()以外, __setitem__()和__delitem__()又是干嘛用的?</h3>

<p>答:  __setitem__()把实例对象视为list或dict来对集合赋值, __delitem__()用来删除某个元素; 通过这3个方法, 我们自己构造的类和python自带的list, tuple, dict 也差不多了, 类似鸭子类型</p>

<h3 id="24-问-__getattr__self-attr是用来做什么的">24. 问: __getattr__(self, attr)是用来做什么的?</h3>

<p>答: 访问类中不存在的属性或者调用不存在的方法时, 会调用 __getattr__方法, 可以自定义返回的值 ; 默认返回None值, 可以使用 raise AttributeError (“  “, attr)去格式化想输出的错误信息</p>

<h3 id="25-问-当一个实例想要调用实例方法时-一般会以instancemethod这种方式调用-那可不可以直接使用instance调用呢">25. 问: 当一个实例想要调用实例方法时, 一般会以instance.method()这种方式调用, 那可不可以直接使用instance()调用呢?</h3>

<p>答: 可以, 定义一个__call__()方法, 相当于就把实例对象看成一个函数去调用</p>

<h3 id="26-问-那怎么判断一个对象能否被调用呢">26. 问: 那怎么判断一个对象能否被调用呢?</h3>

<p>答: 只需要判断一个对象是否可以被调用, 使用callable(对象)函数判断是否是可调用callable的对象,</p>

<h3 id="27-问-需要定义常量时-怎么使用枚举类">27. 问: 需要定义常量时, 怎么使用枚举类?</h3>

<p>答: from enum import Enum 导入枚举类, 枚举类的value属性是自动赋值给成员的int型常量, 注意是从1开始的   ; 还可以导入@unique装饰器保证没有重复值</p>

<h3 id="28-问-不使用class还能怎么样创建一个类呢">28. 问: 不使用class还能怎么样创建一个类呢?</h3>

<p>答: 使用type()既可以查看对象的类型, 同时又可用于创建类 ; 事实上解释器在扫描完class定义的语法后就是使用type去创建这个类的; 使用type()相当于是动态的创建类, type(类名, (继承的父类, …), dict(类的方法名=外部方法))</p>

<h3 id="29-问-什么是元类metaclass">29. 问: 什么是元类metaclass?</h3>

<p>答:  元类允许创建或修改类 metaclass==&gt;class==&gt;instance, 元类用来控制类的创建行为, 定义元类一般以Metaclass结尾, 是Python面向对象里最难理解，也是最难使用的魔术代码</p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>KeyWord</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python中的关键字</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python中的关键字 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python中的关键字" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="解释器版本: Python3.6" />
<meta property="og:description" content="解释器版本: Python3.6" />
<link rel="canonical" href="http://localhost:4000/Python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97" />
<meta property="og:url" content="http://localhost:4000/Python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-15T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python中的关键字" />
<script type="application/ld+json">
{"description":"解释器版本: Python3.6","headline":"Python中的关键字","dateModified":"2020-10-15T00:00:00+08:00","url":"http://localhost:4000/Python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97","datePublished":"2020-10-15T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python中的关键字</h2>
  <time datetime="2020-10-15T00:00:00+08:00" class="by-line">15 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>KeyWord</a></span>
  
  <p><strong>解释器版本: Python3.6</strong></p>

<p>查看python中的关键字</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">keyword</span>
<span class="k">print</span><span class="p">(</span><span class="n">keyword</span><span class="p">.</span><span class="n">kwlist</span><span class="p">)</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">'False'</span><span class="p">,</span> <span class="s">'None'</span><span class="p">,</span> <span class="s">'True'</span><span class="p">,</span> <span class="s">'and'</span><span class="p">,</span> <span class="s">'as'</span><span class="p">,</span> <span class="s">'assert'</span><span class="p">,</span> <span class="s">'break'</span><span class="p">,</span> <span class="s">'class'</span><span class="p">,</span> <span class="s">'continue'</span><span class="p">,</span> <span class="s">'def'</span><span class="p">,</span> <span class="s">'del'</span><span class="p">,</span> <span class="s">'elif'</span><span class="p">,</span> <span class="s">'else'</span><span class="p">,</span> <span class="s">'except'</span><span class="p">,</span>
 <span class="s">'finally'</span><span class="p">,</span> <span class="s">'for'</span><span class="p">,</span> <span class="s">'from'</span><span class="p">,</span> <span class="s">'global'</span><span class="p">,</span> <span class="s">'if'</span><span class="p">,</span> <span class="s">'import'</span><span class="p">,</span> <span class="s">'in'</span><span class="p">,</span> <span class="s">'is'</span><span class="p">,</span> <span class="s">'lambda'</span><span class="p">,</span> <span class="s">'nonlocal'</span><span class="p">,</span> <span class="s">'not'</span><span class="p">,</span> <span class="s">'or'</span><span class="p">,</span> <span class="s">'pass'</span><span class="p">,</span> <span class="s">'raise'</span><span class="p">,</span> <span class="s">'return'</span><span class="p">,</span> <span class="s">'try'</span><span class="p">,</span> <span class="s">'while'</span><span class="p">,</span> <span class="s">'with'</span><span class="p">,</span> <span class="s">'yield'</span><span class="p">]</span>
</code></pre></div></div>
<p>看下一共多少个关键字 (3.6版本中)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">.</span><span class="n">kwlist</span><span class="p">))</span>
</code></pre></div></div>
<p><strong>一共33个</strong></p>

<p>让我们来梳理一下这些关键字都是干嘛的<br />
<code class="language-plaintext highlighter-rouge">None</code> 空<br />
<code class="language-plaintext highlighter-rouge">del</code> 删除<br />
<code class="language-plaintext highlighter-rouge">with</code> 上下文<br />
<code class="language-plaintext highlighter-rouge">assert</code> 断言<br />
<code class="language-plaintext highlighter-rouge">lambda</code> 匿名函数<br />
<code class="language-plaintext highlighter-rouge">True False</code> 布尔<br />
<code class="language-plaintext highlighter-rouge">from import as</code> 导包<br />
<code class="language-plaintext highlighter-rouge">def class</code> 定义函数和类<br />
<code class="language-plaintext highlighter-rouge">if elif else</code> 条件判断<br />
<code class="language-plaintext highlighter-rouge">for in while</code> 循环语句<br />
<code class="language-plaintext highlighter-rouge">is or and not</code> 逻辑判断<br />
<code class="language-plaintext highlighter-rouge">continue break</code> 结束循环<br />
<code class="language-plaintext highlighter-rouge">global nonlocal</code> 全局变量<br />
<code class="language-plaintext highlighter-rouge">pass return yield</code> 函数返回<br />
<code class="language-plaintext highlighter-rouge">try except finally raise</code> 异常处理</p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Syntax</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 6 -- 容器的公共方法</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 6 – 容器的公共方法 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 6 – 容器的公共方法" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="公共方法" />
<meta property="og:description" content="公共方法" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-6-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-6-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-17T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 6 – 容器的公共方法" />
<script type="application/ld+json">
{"description":"公共方法","headline":"Python容器篇 6 – 容器的公共方法","dateModified":"2020-10-17T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-6-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95","datePublished":"2020-10-17T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-6-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 6 -- 容器的公共方法</h2>
  <time datetime="2020-10-17T00:00:00+08:00" class="by-line">17 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>公共方法</strong></p>

<p><strong>运算符</strong><br /></p>

<p>对于str, list 和 tuple 这三个类型, 算数运算符 +号 和 *号 属于公有方法<br /></p>

<table>
  <thead>
    <tr>
      <th>算数运算符</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>+号</td>
      <td>拼接</td>
    </tr>
    <tr>
      <td>*号</td>
      <td>复制 (倍增)</td>
    </tr>
  </tbody>
</table>

<p>并不能用于 dict 和 set 类型的数据!<br /></p>

<p>对于所有的5个容器 str, list, tuple, dict 和 set<br />
判断是否存在的方法<strong>in/not in</strong>都通用<br /></p>

<ul>
  <li>注意: 对于字典dict来说, in/not in 仅仅判断key是否存在</li>
</ul>

<p><strong>Python内置函数</strong><br /></p>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>len()</td>
      <td>计算容器中元素的个数</td>
    </tr>
    <tr>
      <td>max()</td>
      <td>返回容器中元素的最大值</td>
    </tr>
    <tr>
      <td>min()</td>
      <td>返回容器中元素的最小值</td>
    </tr>
    <tr>
      <td>del()</td>
      <td>删除变量</td>
    </tr>
  </tbody>
</table>

<p>对于多维度list和tuple的访问<br />
<code class="language-plaintext highlighter-rouge">变量名[x][y][...]</code><br /></p>

<p>带索引的遍历结果<br /></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>结果 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>o a
1 b
2 c
</code></pre></div></div>

<p>枚举函数 enumerate()<br /></p>

<ul>
  <li>将一个可遍历的数据对象组合成一个索引序列, 并同时列出下标和数据
<br />
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>结果 <br /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>o a
1 b
2 c
</code></pre></div>    </div>
  </li>
</ul>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 5 -- 集合</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 5 – 集合 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 5 – 集合" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="集合" />
<meta property="og:description" content="集合" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-5-%E9%9B%86%E5%90%88" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-5-%E9%9B%86%E5%90%88" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 5 – 集合" />
<script type="application/ld+json">
{"description":"集合","headline":"Python容器篇 5 – 集合","dateModified":"2020-10-16T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-5-%E9%9B%86%E5%90%88","datePublished":"2020-10-16T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-5-%E9%9B%86%E5%90%88"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 5 -- 集合</h2>
  <time datetime="2020-10-16T00:00:00+08:00" class="by-line">16 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>集合</strong></p>

<p><code class="language-plaintext highlighter-rouge">set = {item1, item2, ...}</code></p>

<p>创建一个空集合:</p>
<ol>
  <li>em_set = set() # 只有这一种方式, {}已经被用作创建空字典!</li>
</ol>

<p>集合这种容器, 貌似是5大容器中最没有存在感, 也确实是用的最少的一种;<br />
但是, 它的作用却很重要!<br /></p>

<p>集合和字典一样, 都属于无序的数据类型!<br /></p>

<p>集合的特点 (重要)</p>
<ul>
  <li>集合中不存在重复的元素</li>
  <li>那么, 集合的其中一个很重要的作用就是<strong>去重</strong>了!</li>
</ul>

<p>可变和不可变特性</p>
<ul>
  <li>集合本身是可变的, 也就是说集合中的元素可以被删除, 同时也可以往集合中添加新的元素</li>
  <li>但是集合中的元素必须是不可变的, 也就是集合中的元素不能是列表和字典以及特殊的元组</li>
  <li>至于修改元素, 这个功能对于集合来说不太适用, 因为集合中的元素既没有下标, 也没有像是字典那样的元素唯一标识(key), 也正是因为如此, 集合才会强制要求其中的元素是不可变的</li>
</ul>

<p>解释一下什么叫特殊的元组, 元组本身不可变对吧, 看似很符合作为集合中元素的条件;<br />
但是如果元组中有一个列表呢? 比如: <code class="language-plaintext highlighter-rouge">my_set = {1, 2, "hello", (3, 4, [5, 6])}</code><br />
这种情况下, 虽然(3, 4, [5, 6])本身不可变, 但是[5, 6]这个列表是能变的, 比如变成[7, 8];<br />
所以定义这样的非法集合是会报错的! <br /></p>

<p>集合的添加</p>
<ol>
  <li>set.add()</li>
  <li>set.update()
    <ul>
      <li>update这个方法的参数可以是可变对象, 它会把可变对象中的不可变元素提取出来</li>
      <li>update添加的元素一定是最原子性的不可变对象 (拆到不能再拆)</li>
    </ul>
  </li>
</ol>

<p>集合的删除</p>
<ol>
  <li>set.remove()
    <ul>
      <li>元素不存在, 直接报错</li>
    </ul>
  </li>
  <li>set.discard()
    <ul>
      <li>元素不存在, 不会报错</li>
    </ul>
  </li>
  <li>set.pop()
    <ul>
      <li>随机删除一个元素, 并把它返回出来</li>
    </ul>
  </li>
</ol>

<p>集合的大小</p>

<ul>
  <li>len(set)</li>
</ul>

<p>清空集合</p>

<ul>
  <li>set.clear()</li>
</ul>

<p>是否存在某个元素</p>

<ul>
  <li>item in/not in set</li>
</ul>

<p><strong>集合不需要也不能单独查某个元素</strong>
<strong>集合不需要count函数去统计出现次数因为集合中的元素只能出现1次</strong></p>

<p><strong>集合推导式</strong></p>

<p><code class="language-plaintext highlighter-rouge">aset = {x for x in 可迭代对象 if 条件}</code></p>

<p>集合的常用方法<br /></p>

<ol>
  <li>减法算数运算 (集合独占)</li>
</ol>

<p>相当于求补集</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="n">cset</span> <span class="o">=</span> <span class="n">aset</span> <span class="o">-</span> <span class="n">bset</span>
<span class="k">print</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
</code></pre></div></div>
<p>结果</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1, 3, 5}
</code></pre></div></div>

<ol>
  <li>集合运算 (类似于数学中集合的运算)</li>
</ol>

<ul>
  <li>取并集 | (包含于集合a的所有元素 + 包含于集合b的所有元素)
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="n">cset</span> <span class="o">=</span> <span class="n">aset</span> <span class="o">|</span> <span class="n">bset</span>
<span class="k">print</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>结果<br /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1, 2, 3, 4, 5, 6}
</code></pre></div>    </div>
  </li>
  <li>取交集 &amp; (包含于集合a, 且同时包含于集合b)
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">cset</span> <span class="o">=</span> <span class="n">aset</span> <span class="o">&amp;</span> <span class="n">bset</span>
<span class="k">print</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>结果<br /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1, 2}
</code></pre></div>    </div>
  </li>
  <li>补集的并集 ^ (不同时包含于集合a和集合b的元素)</li>
</ul>

<p>首先理解一下补集是啥?<br /></p>

<p>补集 –&gt; 补充用的集合<br />
谁对谁补充, 需要2个对象!<br />
比如: <br /></p>
<ul>
  <li>A对B的补集, 就是B里没有但是A里有的元素组成的补充集合, 用A去补充B所需要的A中的部分元素</li>
  <li>B对A的补集, 就是A里没有但是B里有的元素组成的补充集合, 用B去补充A所需要的B中的部分元素</li>
</ul>

<p>那么, 补集的并集就是 A对B的补充加上B对A的补充, 注意仅是补充的部分!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">bset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
<span class="n">cset</span> <span class="o">=</span> <span class="n">aset</span> <span class="o">^</span> <span class="n">bset</span>
<span class="k">print</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
</code></pre></div></div>
<p>结果<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1, 3, 5, 6, 8, 10}
# A对B的补集 {1, 3, 5}
# B对A的补集{6, 8, 10}
</code></pre></div></div>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 4 -- 字典</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 4 – 字典 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 4 – 字典" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="字典" />
<meta property="og:description" content="字典" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-4-%E5%AD%97%E5%85%B8" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-4-%E5%AD%97%E5%85%B8" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 4 – 字典" />
<script type="application/ld+json">
{"description":"字典","headline":"Python容器篇 4 – 字典","dateModified":"2020-10-16T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-4-%E5%AD%97%E5%85%B8","datePublished":"2020-10-16T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-4-%E5%AD%97%E5%85%B8"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 4 -- 字典</h2>
  <time datetime="2020-10-16T00:00:00+08:00" class="by-line">16 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>字典</strong></p>

<p><code class="language-plaintext highlighter-rouge">dict = {key1:value1, key2:value2, ...}</code></p>

<p>定义一个空字典</p>
<ol>
  <li>em_dict = dict()</li>
  <li>em_dict = {}</li>
</ol>

<p>字典的特性</p>
<ul>
  <li>可能存在多个相同的value(可重复), 但是key绝对是唯一存在的!</li>
  <li>字典不支持下标/索引和切片, 字典是通过key(键)来访问的</li>
</ul>

<p>查找字典数据</p>
<ol>
  <li>dict[key]
    <ul>
      <li>这种访问方式, 如果key不存在, 会直接报错</li>
    </ul>
  </li>
  <li>dict.get(key)
    <ul>
      <li>这种方式, 如果key不存在, 不会报错, 而是返回 None</li>
    </ul>
  </li>
  <li>dict.get(key, default)
    <ul>
      <li>这种方式更细致, 如果key不存在, 不会返回 None, 而是返回默认值 default</li>
    </ul>
  </li>
</ol>

<p>修改和添加字典数据</p>
<ol>
  <li>dict[key] = value
    <ul>
      <li>如果key存在, 做修改操作</li>
      <li>如果key不存在, 在末尾做添加操作</li>
    </ul>
  </li>
  <li>dict.update({key:value, …})
    <ul>
      <li>这种方法是用字典型的数据去做添加修改操作</li>
      <li>如果key存在, 做修改操作</li>
      <li>如果key不存在, 在末尾做添加操作</li>
    </ul>
  </li>
</ol>

<p>删除字典数据</p>
<ol>
  <li>删除指定元素(键值对)
    <ul>
      <li>del dict[key]</li>
      <li>dict.pop(key)</li>
    </ul>
  </li>
  <li>删除整个字典
    <ul>
      <li>del dict</li>
      <li>dict.clear()</li>
    </ul>
  </li>
</ol>

<p>字典的长度</p>
<ul>
  <li>长度就是键值对的个数</li>
  <li>len(dict)</li>
</ul>

<p>返回包含字典中所有key值的一个列表</p>
<ul>
  <li>dict.keys()</li>
</ul>

<p>返回包含字典中所有value值的一个列表</p>
<ul>
  <li>dict.values()</li>
</ul>

<p>返回包含字典中所有键值对元组的一个列表</p>
<ul>
  <li>列表中的元素形如 (key, value)</li>
  <li>dict.items()</li>
</ul>

<p><strong>遍历字典</strong></p>
<ol>
  <li>直接遍历(也就相当于只遍历key值)
    <ul>
      <li>for key in dict:</li>
    </ul>
  </li>
  <li>遍历字典的key值
    <ul>
      <li>for key in dict.keys():</li>
    </ul>
  </li>
  <li>遍历字典的value值
    <ul>
      <li>for value in dict.values():</li>
    </ul>
  </li>
  <li>遍历字典中的的元素(键值对)
    <ul>
      <li>for item in dict.items():</li>
      <li>一定要注意了, 此处返回值是元组类型的 (key, value)</li>
    </ul>
  </li>
  <li>遍历字典中的key,value键值对:
    <ul>
      <li>for key, value in dict.items():</li>
      <li>注意, 此处相当于一个元组的拆包操作, 把(key, value)拆出来给key和value变量</li>
    </ul>
  </li>
</ol>

<p><strong>关于有序字典和无序字典</strong></p>

<p>既然字典没有下标去定位顺序, 那么自然有个疑问, 字典中的元素是有序地存放着的吗??<br /></p>

<p>其实字典这个容器分为有序字典和无序字典, 在Python3.6版本之后, 我们创建的dict默认就是有序字典<br /></p>

<p>而在3.6版本之前, 我们创建的dict则默认是无序字典, 无序字典的特点是:每次访问, 字典中元素的顺序是随机的!<br /></p>

<p>那么问题来了, 如果想在3.6之前的版本环境下创建一个有序字典怎么办呢??<br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="n">my_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># 创建一个有序字典
</span></code></pre></div></div>

<p>但是即使3.6版本后的字典中元素是默认有序的存放的, 但是, 注意但是, 字典这种类型的容器在归类上是属于无序的数据类型的!!!<br /></p>

<p>那么, 这个数据类型的有序和无序是怎么看的呢?<br /></p>

<p>主要还是看能不能用下标索引出来, <br />
比如: 字符串, 元组 和 列表 这仨就是有序数据类型<br />
而: 字典 和 集合 这俩就是无序的<br /></p>

<p>也可以这么理解, 字典这种数据类型在绝大多数编程语言中都是无序的;<br />
只不过python3.6版本后做了个数据类型的小优化, 让字典内部的元素有序地进行存放; <br />
但是这并无法改变字典这种数据类型的本质, 综上所述字典是一种无序数据类型!</p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 3 -- 元组</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 3 – 元组 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 3 – 元组" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="元组" />
<meta property="og:description" content="元组" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-3-%E5%85%83%E7%BB%84" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-3-%E5%85%83%E7%BB%84" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 3 – 元组" />
<script type="application/ld+json">
{"description":"元组","headline":"Python容器篇 3 – 元组","dateModified":"2020-10-16T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-3-%E5%85%83%E7%BB%84","datePublished":"2020-10-16T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-3-%E5%85%83%E7%BB%84"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 3 -- 元组</h2>
  <time datetime="2020-10-16T00:00:00+08:00" class="by-line">16 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>元组</strong></p>

<p><code class="language-plaintext highlighter-rouge">tuple = (item1, item2, ...)</code></p>

<p>定义一个空元组:</p>

<ol>
  <li>em_tuple = tuple()</li>
  <li>em_tuple = ()</li>
</ol>

<p>定义单一元素元组</p>
<ul>
  <li>oneitem_tuple = (item, )  # 注意: 必须要加逗号!!!</li>
</ul>

<p>元组的特点</p>
<ul>
  <li>一旦定义好, 就不能添加修改和删除其中的元素, 只能查看</li>
  <li>例外: 如果元组中的某个元素是一个容器(比如list), 只要这个容器支持增删改, 那么该容器中的元素就能够做相应的操作</li>
</ul>

<p>元组的查询</p>

<p>元组和列表的查询类似, 都没有find函数, 原因是find函数是字符串类型独占的方法!<br /></p>
<ol>
  <li>查找某个元素的下标
    <ul>
      <li>tuple.index(元素值)</li>
    </ul>
  </li>
  <li>统计元素出现的次数
    <ul>
      <li>tuple.count(元素值)</li>
    </ul>
  </li>
  <li>元素是否存在
    <ul>
      <li>item in/not in tuple</li>
    </ul>
  </li>
</ol>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 2 -- 列表</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 2 – 列表 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 2 – 列表" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="列表" />
<meta property="og:description" content="列表" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-2-%E5%88%97%E8%A1%A8" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-2-%E5%88%97%E8%A1%A8" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-15T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 2 – 列表" />
<script type="application/ld+json">
{"description":"列表","headline":"Python容器篇 2 – 列表","dateModified":"2020-10-15T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-2-%E5%88%97%E8%A1%A8","datePublished":"2020-10-15T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-2-%E5%88%97%E8%A1%A8"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 2 -- 列表</h2>
  <time datetime="2020-10-15T00:00:00+08:00" class="by-line">15 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>列表</strong></p>

<p><code class="language-plaintext highlighter-rouge">list = [item1, item2, ...]</code></p>
<ul>
  <li>
    <p>如何定义空列表</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. em_list = list()
2. em_list = []
</code></pre></div>    </div>
  </li>
  <li>
    <p>如何遍历一个列表
```python</p>
    <h1 id="for循环">for循环</h1>
    <p>for i in alist:
    print(i)</p>
  </li>
</ul>

<h1 id="while循环">while循环</h1>
<p>i = 0
while i &lt; len(alist):
      print(alist[i])
      i += 1
```</p>

<p><strong>和字符串一样, 列表既支持下标/索引, 同时也支持切片</strong></p>

<p>从 增删改查 4个角度梳理列表常用的操作方法<br /></p>

<p>修改元素<br /></p>

<ul>
  <li>列表名[下标] = 新的元素值</li>
</ul>

<p>添加元素<br /></p>

<ol>
  <li>列表名.append(元素值)
    <ul>
      <li>追加到列表的尾部</li>
    </ul>
  </li>
  <li>列表名.insert(index, 元素值)
    <ul>
      <li>可以在列表的任意位置插入</li>
      <li>index代表要插入的下标位置</li>
    </ul>
  </li>
  <li>列表名.extend(可迭代对象)
    <ul>
      <li>把可迭代对象遍历出来后, 一个一个放在列表尾部</li>
    </ul>
  </li>
</ol>

<p><strong>append, insert, extend 这些函数都会直接操作原列表, 而且函数的返回值为 None</strong></p>

<p>查找元素<br /></p>

<p>和字符串不同, 列表不存在find方法 (字符串独占)<br /></p>

<ol>
  <li>列表名.index(元素值)
    <ul>
      <li>返回元素所在位置的下标</li>
    </ul>
  </li>
  <li>列表名.count(元素值)
    <ul>
      <li>统计同一个元素出现的总次数, 返回出现次数</li>
    </ul>
  </li>
  <li>元素 in/not in 列表名
    <ul>
      <li>判断元素在不在列表中</li>
      <li>返回布尔值 True/False</li>
    </ul>
  </li>
</ol>

<p>删除元素<br /></p>

<ol>
  <li>列表名.remove(元素)
    <ul>
      <li>根据元素值删除</li>
      <li>删除不存在的数据时, 会直接报错</li>
      <li>返回值 None</li>
    </ul>
  </li>
  <li>del 列表名[下标]
    <ul>
      <li>根据下标删除</li>
      <li>后边的元素会自动向前移动</li>
    </ul>
  </li>
  <li>列表名.pop(下标)
    <ul>
      <li>根据下标删除</li>
    </ul>
  </li>
  <li>列表名.pop()
    <ul>
      <li>默认删除列表最后一个元素</li>
      <li>会将被删除的元素返回出来</li>
      <li>需要从列表中取数据, 同时缩短列表的情况下使用</li>
    </ul>
  </li>
</ol>

<p><strong>remove, del, pop 这三种方法都是会直接操作原列表, remove返回None, pop返回被删除的元素值</strong></p>

<p>列表排序<br /></p>

<ol>
  <li>直接操作原列表
    <ul>
      <li>升序排序 list.sort()</li>
      <li>降序排序 list.sort(reverse=True)</li>
    </ul>
  </li>
  <li>不修改原列表, 而是返回一个新列表
    <ul>
      <li>函数 sorted(list)</li>
    </ul>
  </li>
</ol>

<p>列表逆置(反转)<br /></p>

<p>注意: 反转与大小排序无关, 只是单纯的倒过来<br /></p>

<ol>
  <li>直接操作原列表
    <ul>
      <li>list.reverse()</li>
    </ul>
  </li>
  <li>不修改原列表, 而是返回一个新的列表
    <ul>
      <li>list[::-1] 用上了切片 步长 -1</li>
    </ul>
  </li>
</ol>

<p>列表嵌套<br /></p>

<p>列表中有的的元素还是列表<br /></p>

<p>嵌套的外层还是按照列表的正常操作去做, 而内层则需要双重下标才能访问的到<br /></p>

<p>列表 list = […, alist, …] 的第i个元素是 alist<br /></p>

<p>那么就需要用 list[i][j] 去访问 alist的第j个元素</p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python容器篇 1 -- 字符串</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python容器篇 1 – 字符串 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python容器篇 1 – 字符串" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Python中有5种类型的容器 字符串 列表 元组 字典 集合" />
<meta property="og:description" content="Python中有5种类型的容器 字符串 列表 元组 字典 集合" />
<link rel="canonical" href="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-1-%E5%AD%97%E7%AC%A6%E4%B8%B2" />
<meta property="og:url" content="http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-1-%E5%AD%97%E7%AC%A6%E4%B8%B2" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-15T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python容器篇 1 – 字符串" />
<script type="application/ld+json">
{"description":"Python中有5种类型的容器 字符串 列表 元组 字典 集合","headline":"Python容器篇 1 – 字符串","dateModified":"2020-10-15T00:00:00+08:00","url":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-1-%E5%AD%97%E7%AC%A6%E4%B8%B2","datePublished":"2020-10-15T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E5%AE%B9%E5%99%A8%E7%AF%87-1-%E5%AD%97%E7%AC%A6%E4%B8%B2"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python容器篇 1 -- 字符串</h2>
  <time datetime="2020-10-15T00:00:00+08:00" class="by-line">15 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Syntax</a></span>
  
  <p><strong>Python中有5种类型的容器</strong></p>
<ol>
  <li>字符串</li>
  <li>列表</li>
  <li>元组</li>
  <li>字典</li>
  <li>集合</li>
</ol>

<hr />

<p><strong>字符串</strong></p>

<p>表现形式: <code class="language-plaintext highlighter-rouge">"str"和'str'或者"""str"""和'''str'''</code></p>
<ul>
  <li>单引号, 双引号表示的字符串通常用在变量赋值中</li>
  <li>而三引号表示的字符串通常来说是注释</li>
</ul>

<p>访问字符串中的元素</p>
<ul>
  <li>通过下标/索引的方式去访问单个元素</li>
  <li>通过切片的方式截取多个元素</li>
</ul>

<p>下标/索引的顺序</p>
<ul>
  <li>正序: 从0开始, 最后一个元素是 len(str)-1</li>
  <li>倒序: 从-1开始, 最后一个元素是 -len(str)</li>
</ul>

<p>切片: [start: end: step]</p>
<ul>
  <li>从第start位元素开始, 直到end之前一位元素为止, 间隔是step
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 举例: 
</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"ABCDEFG"</span>
<span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 是 "ABCD"
</span><span class="nb">str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 是 "GFE"
</span></code></pre></div>    </div>
  </li>
  <li>如果省略步长, 那么默认值是 1, 如果省略开始位, 那么默认值是0, 省略结束位, 默认值是len(str)</li>
  <li>取所有元素 str[ : ] str[ : : ]</li>
  <li>从下标为x的元素一直截取到结尾 str[x: ]</li>
  <li>从第一个元素开始一直截取到y前面的一个元素 str[ :y]</li>
  <li>以步长为a正序访问所有元素 str[ : : a]</li>
  <li>以步长为b倒序访问所有元素 str[ : : -b]</li>
  <li>反转字符串(倒序访问每一个元素) str[ : : -1]</li>
  <li>切片截取操作不会影响原字符串变量, 而是生成一个新的字符串变量</li>
</ul>

<p><strong>字符串类型的常用方法</strong></p>

<p>查找</p>
<ol>
  <li>str.find(“要查的部分”, start, end)  # find方法时字符串特有的查找方法
    <ul>
      <li>默认start=0, end=len(str)</li>
      <li>找到返回 “要查的部分” 开始位置的下标</li>
      <li>找不到返回 -1</li>
    </ul>
  </li>
  <li>str.index(“要查的部分”, start, end)
    <ul>
      <li>默认start=0, end=len(str)</li>
      <li>找到返回 “要查的部分” 开始位置的下标</li>
      <li>找不到则会直接抛出异常 ValueError</li>
    </ul>
  </li>
</ol>

<p>统计出现次数</p>
<ol>
  <li>str.count(“要统计的部分”, start, end)
    <ul>
      <li>默认start=0, end=len(str)</li>
      <li>返回数字型结果</li>
    </ul>
  </li>
</ol>

<p>替换</p>
<ol>
  <li>str.replace(str1, str2, count)
    <ul>
      <li>把str1替换成str2, 置于替换几次就看count了</li>
      <li>默认 count=str.count(str1), 也就是全部替换</li>
    </ul>
  </li>
</ol>

<p>分隔</p>
<ol>
  <li>str.split(str=”分隔依据”, maxsplit)
    <ul>
      <li>maxsplit存在, 那么仅仅把字符串分成 maxsplit+1 个部分</li>
      <li>分隔依据可以不写, 默认是按照空白字符(‘’‘\t’‘\n’)来分隔</li>
      <li>如果存在分隔依据, 那么按照分隔依据去分隔, 但是结果中会把分隔依据剔除掉</li>
      <li>得到的结果默认是list类型的一个列表 &lt;class ‘list’&gt;</li>
    </ul>
  </li>
</ol>

<p>插空加入</p>
<ol>
  <li>str.join(alist)
    <ul>
      <li>把字符串str当作内容插入到alist中形成另一个字符串</li>
    </ul>
  </li>
</ol>

<p><strong>替换, 分隔, 插空加入这三种操作都不会影响原来的str, 而是返回一个新的str</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>举例: 
alist = ["a", "b", "c"] 
str="_"
str.join(alist)的结果是 "a_b_c"
</code></pre></div></div>

<p><strong>其他比较重要的常用方法</strong></p>

<p>大小写变换</p>
<ul>
  <li>第一个字符如果是字母就变成大写 .capitalize()   # 应该比较适合处理英文文本</li>
  <li>每一个单词的首字母大写 .title()</li>
  <li>全部换成小写字母 .lower()</li>
  <li>全部换成大写字母 .upper()</li>
</ul>

<p>检测开头结尾的字符</p>
<ul>
  <li>检测是否以某段字符串开头 .startswith(“…”)  # 注意s</li>
  <li>检测是否以某段字符串结尾 .endswith(“…”)  # 注意s</li>
</ul>

<p>对齐方式</p>
<ul>
  <li>左对齐, 并以空格填充至某个长度 .ljust(width)</li>
  <li>右对齐, 并以空格填充至某个长度 .rjust(width)</li>
  <li>居中对齐, 并以空格填充至某个长度 .center(width)</li>
</ul>

<p>删除空白符</p>
<ul>
  <li>删除字符串左边起的空白符 .lstrip()</li>
  <li>删除字符串右边起的空白符 .rstrip()</li>
</ul>

<p>查找</p>
<ul>
  <li>类似于find方法, 但从最右边开始找 .rfind(“…”, start, end)</li>
  <li>类似于index方法, 但从最右边开始找 .rindex(“…”, start, end)</li>
</ul>

<p>分割</p>
<ul>
  <li>把字符串根据分割依据str分割成, str之前, str, str之后三个部分 .partition(str)</li>
  <li>类似于partition, 但从最右边开始 .rpartition(str)</li>
  <li>按照行进行分割, 返回一个列表, 每个元素就是字符串的每一行 .splitlines()</li>
</ul>

<p>判断内容的类型</p>
<ul>
  <li>是否只含字母 .isalpha()</li>
  <li>是否只含数字 .isdigit()</li>
  <li>是否只含字母和数字 .isalnum()</li>
  <li>是否只含空格字符 .isspace()</li>
</ul>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Virtual Environment</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Python虚拟环境</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python虚拟环境 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Python虚拟环境" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="虚拟环境 Virtual Environment Python版本3.6 模块venv – 创建轻量级的虚拟环境" />
<meta property="og:description" content="虚拟环境 Virtual Environment Python版本3.6 模块venv – 创建轻量级的虚拟环境" />
<link rel="canonical" href="http://localhost:4000/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83" />
<meta property="og:url" content="http://localhost:4000/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-18T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python虚拟环境" />
<script type="application/ld+json">
{"description":"虚拟环境 Virtual Environment Python版本3.6 模块venv – 创建轻量级的虚拟环境","headline":"Python虚拟环境","dateModified":"2020-10-18T00:00:00+08:00","url":"http://localhost:4000/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83","datePublished":"2020-10-18T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Python虚拟环境</h2>
  <time datetime="2020-10-18T00:00:00+08:00" class="by-line">18 Oct 2020</time>
   
  <span>分类:<a>Python</a></span>
  
   
  <span>标签:<a>Virtual Environment</a></span>
  
  <p>虚拟环境 Virtual Environment<br />
Python版本3.6<br />
模块venv – 创建轻量级的虚拟环境<br /></p>

<blockquote>
  <p>虚拟环境主要作用:</p>
  <ol>
    <li>为每个应用隔离出自己需要的环境 (库, 包)</li>
    <li>方便管理, 需要创建, 不需要了就删除</li>
    <li>避免本机的真实环境中模块的混淆和冗余</li>
  </ol>
</blockquote>

<p>由于我的真实机中不止一个版本的Python环境, 设置环境变量依然容易混淆, 所以我的命令都用绝对路径执行<br />
目前我的真实机中有3.6的64位和32位版本以及2.7的64位和32位版本, 全都安装在C盘下<br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\
|
`--Python27
|
`--Python27-32
|
`--Python36
|
`--Python36-32
</code></pre></div></div>

<p>我用Python3.6 (64-bit) 创建虚拟环境的命令如下,<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\Python36\python -m venv d:\虚拟环境存放的路径
</code></pre></div></div>

<p>激活虚拟环境<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d:\虚拟环境存放的路径\Scripts\activate.bat
</code></pre></div></div>

<p>退出虚拟环境<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d:\虚拟环境存放的路径\Scripts\deactivate.bat
</code></pre></div></div>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>ArchLinux</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>ArchLinux安装记录</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>ArchLinux安装记录 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="ArchLinux安装记录" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="准备工作" />
<meta property="og:description" content="准备工作" />
<link rel="canonical" href="http://localhost:4000/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95" />
<meta property="og:url" content="http://localhost:4000/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-10T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="ArchLinux安装记录" />
<script type="application/ld+json">
{"description":"准备工作","headline":"ArchLinux安装记录","dateModified":"2020-11-10T00:00:00+08:00","url":"http://localhost:4000/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95","datePublished":"2020-11-10T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/ArchLinux%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>ArchLinux安装记录</h2>
  <time datetime="2020-11-10T00:00:00+08:00" class="by-line">10 Nov 2020</time>
   
  <span>分类:<a>Linux</a></span>
  
   
  <span>标签:<a>ArchLinux</a></span>
  
  <h1 id="准备工作">准备工作</h1>

<blockquote>
  <ol>
    <li>烧录一个启动U盘<br /></li>
    <li>把Bios调成UEFI启动</li>
  </ol>
</blockquote>

<h1 id="正式安装">正式安装</h1>
<ol>
  <li>检查启动模式<br />
 <code class="language-plaintext highlighter-rouge">ls /sys/firmware/efi/efivars</code><br />
 如果没有efi目录则说明U盘系统不是用UEFI启动的<br />
 现在的笔记本只要不是太次的都用UEFI启动了</li>
  <li>修改终端字体<br />
 默认的终端字体太小, 需要改一下字体方便安装;<br />
 推荐设置字体 <code class="language-plaintext highlighter-rouge">setfont /usr/share/kbd/consolefonts/LatGrkCyr-12x22.psfu.gz</code></li>
  <li>联网
    <ul>
      <li>看下网络设备(网卡) <code class="language-plaintext highlighter-rouge">ip link</code></li>
      <li>启动(up)网卡 <code class="language-plaintext highlighter-rouge">ip link set 网卡名 up</code></li>
      <li>我一般用无线网， 扫描一下附近的wifi <code class="language-plaintext highlighter-rouge">iwlist 无线网卡名 scan | grep ESSID</code></li>
      <li>生成wifi配置文件 <code class="language-plaintext highlighter-rouge">wpa_passphrase wifi名 密码 &gt; internet.conf</code></li>
      <li>连接无线网 <code class="language-plaintext highlighter-rouge">wpa_supplicant -c internet.conf -i 无线网卡名 &amp;</code></li>
      <li>动态分配IP地址 <code class="language-plaintext highlighter-rouge">dhcpcd &amp;</code></li>
      <li>测试联通性 <code class="language-plaintext highlighter-rouge">ping baidu.com</code><br /></li>
    </ul>

    <p><strong>建议把联网步骤写入shell脚本，添加到开机启动配置中</strong><br /></p>
  </li>
  <li>更新系统时间
    <ul>
      <li><code class="language-plaintext highlighter-rouge">timedatectl set-ntp true</code></li>
    </ul>
  </li>
  <li>分区(重点)
    <ul>
      <li>先看下存储设备列表 <code class="language-plaintext highlighter-rouge">fdisk -l</code></li>
      <li>根据提示分区，UEFI启动官方要求要分一个启动分区!!!</li>
      <li>我的常用分区，固态512M给/boot分区，16G给swap(内存16G)，剩下全给根目录/; 机械就默认一个分区用来给/home</li>
      <li>格式化分区 /boot 格式化成Fat32 <code class="language-plaintext highlighter-rouge">mkfs.fat -F32 /dev/...p1</code></li>
      <li>格式化swap分区 <code class="language-plaintext highlighter-rouge">mkswap /dev/...p3</code></li>
      <li>格式化根和家分区 <code class="language-plaintext highlighter-rouge">mkfs.ext4 /dev/...p2</code> 和 <code class="language-plaintext highlighter-rouge">mkfs.ext4 /dev/sda1</code></li>
    </ul>
  </li>
  <li>激活swap分区
    <ul>
      <li><code class="language-plaintext highlighter-rouge">swapon /dev/...p3</code></li>
    </ul>
  </li>
  <li>挂载各分区
    <ul>
      <li>先把根分区挂载到U盘系统的/mnt目录下 <code class="language-plaintext highlighter-rouge">mount /dev/...p2 /mnt</code></li>
      <li>在/mnt目录下创建boot和home目录 <code class="language-plaintext highlighter-rouge">mkdir /mnt/boot</code> 和 <code class="language-plaintext highlighter-rouge">mkdir /mnt/home</code></li>
      <li>分别吧挂载home和boot分区 <code class="language-plaintext highlighter-rouge">mount /dev/...p1 /mnt/boot</code> 和 <code class="language-plaintext highlighter-rouge">mount /dev/sda1 /mnt/home</code></li>
    </ul>
  </li>
  <li>确定国内软件源在列表最上边
    <ul>
      <li>拉取软件时添加颜色信息，<code class="language-plaintext highlighter-rouge">vim /etc/pacman.conf</code></li>
      <li>修改镜像源的顺序 <code class="language-plaintext highlighter-rouge">vim /etc/pacman.d/mirrorlist</code></li>
    </ul>
  </li>
  <li>基础安装
    <ul>
      <li>安装内核和驱动 <code class="language-plaintext highlighter-rouge">pacstrap /mnt base linux linux-firmware</code></li>
      <li><code class="language-plaintext highlighter-rouge">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></li>
    </ul>
  </li>
  <li>进入安装好的系统
    <ul>
      <li><code class="language-plaintext highlighter-rouge">arch-chroot /mnt</code> 进入挂载点所在的系统环境</li>
    </ul>
  </li>
  <li>时区设置
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li>
      <li>同步系统时间 <code class="language-plaintext highlighter-rouge">hwclock --systohc</code></li>
    </ul>
  </li>
  <li>本地化
    <ul>
      <li><code class="language-plaintext highlighter-rouge">exit</code> 先退出挂载点的系统环境</li>
      <li><code class="language-plaintext highlighter-rouge">vim /mnt/etc/locale.gen</code> 开启对应注释(en_US.UTF-8)</li>
      <li>再次进入挂载点的系统环境 <code class="language-plaintext highlighter-rouge">arch-chroot /mnt</code></li>
      <li>生产本地化 <code class="language-plaintext highlighter-rouge">locale-gen</code></li>
      <li>设置语言 <code class="language-plaintext highlighter-rouge">vim /mnt/etc/locale.conf</code> <code class="language-plaintext highlighter-rouge">LANG = en_US.UTF-8</code></li>
    </ul>
  </li>
  <li>修改hostname
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vim /mnt/etc/hostname</code> 写入计算机名</li>
    </ul>
  </li>
  <li>修改hosts
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vim /mnt/etc/hosts</code></li>
      <li>127.0.0.1	localhost</li>
      <li>::1		localhost</li>
      <li>127.0.0.1	hostname.localdomain hostname</li>
    </ul>
  </li>
  <li>修改root密码
    <ul>
      <li>进入挂载系统环境 <code class="language-plaintext highlighter-rouge">passwd 密码</code></li>
    </ul>
  </li>
  <li>配置grub
    <ul>
      <li>安装grub <code class="language-plaintext highlighter-rouge">pacman -S grub efibootmgr intel-ucode os-prober</code></li>
      <li><code class="language-plaintext highlighter-rouge">mkdir /boot/grub</code> <code class="language-plaintext highlighter-rouge">grub-mkconfig /boot/grub/grub.cfg</code></li>
      <li><code class="language-plaintext highlighter-rouge">grub -install --target=x86_64-efi --efi-directory=/boot</code></li>
    </ul>
  </li>
  <li>安装一些软件
    <ul>
      <li>提前安装一些进入系统后必备的软件</li>
      <li><code class="language-plaintext highlighter-rouge">pacman -S vim wpa_supplicant dhcpcd</code>
<br />
<strong>至此archlinux已经安装完毕， reboot通过grub界面进入系统</strong><br /></li>
    </ul>
  </li>
</ol>

<h1 id="安装完成后需要做的事">安装完成后需要做的事</h1>

<ol>
  <li>设置字体
    <ul>
      <li><code class="language-plaintext highlighter-rouge">setfont</code></li>
    </ul>
  </li>
  <li>联网</li>
  <li>更新一下
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pacman -Syyu</code></li>
    </ul>
  </li>
  <li>安装一些基础命令(重要)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pacman -S base-devel</code></li>
    </ul>
  </li>
  <li>安装手册
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pacman -S man</code></li>
    </ul>
  </li>
  <li>添加普通用户
    <ul>
      <li><code class="language-plaintext highlighter-rouge">useradd -G wheel -m 用户名</code> 添加到wheel组</li>
      <li><code class="language-plaintext highlighter-rouge">ln -s /usr/bin/vim /usr/bin/vi</code></li>
      <li>编辑 <code class="language-plaintext highlighter-rouge">visudo</code> 打开wheel组的注释</li>
    </ul>
  </li>
  <li>安装图像界面(重要)
    <ul>
      <li>先安装X服务 <code class="language-plaintext highlighter-rouge">sudo pacman -S xorg xorg-server</code></li>
      <li>选择一个喜欢的桌面环境安装, 本人使用Mate</li>
      <li>安装登录管理器 <code class="language-plaintext highlighter-rouge">sudo pacman -S lightdm lightdm-gtk-greeter</code></li>
      <li>开机启动登录管理器 <code class="language-plaintext highlighter-rouge">systemctl enable lightdm</code></li>
    </ul>
  </li>
  <li>推荐安装
    <ul>
      <li>AUR 推荐yay 从github拉取 <code class="language-plaintext highlighter-rouge">makepkg -si</code></li>
      <li>谷歌Chrome浏览器, <code class="language-plaintext highlighter-rouge">yay -S google-chrome</code></li>
      <li>挂载NTFS格式的设备 <code class="language-plaintext highlighter-rouge">pacman -S ntfs-3g</code></li>
    </ul>
  </li>
</ol>


</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Tool</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Nmap学习笔记</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Nmap学习笔记 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Nmap学习笔记" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="全面扫描 -A 指定C段 用-连接 例: 192.168.0.1-200" />
<meta property="og:description" content="全面扫描 -A 指定C段 用-连接 例: 192.168.0.1-200" />
<link rel="canonical" href="http://localhost:4000/Nmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" />
<meta property="og:url" content="http://localhost:4000/Nmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-12T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Nmap学习笔记" />
<script type="application/ld+json">
{"description":"全面扫描 -A 指定C段 用-连接 例: 192.168.0.1-200","headline":"Nmap学习笔记","dateModified":"2020-11-12T00:00:00+08:00","url":"http://localhost:4000/Nmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0","datePublished":"2020-11-12T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Nmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Nmap学习笔记</h2>
  <time datetime="2020-11-12T00:00:00+08:00" class="by-line">12 Nov 2020</time>
   
  <span>分类:<a>PenTest</a></span>
  
   
  <span>标签:<a>Tool</a></span>
  
  <p>全面扫描 -A
指定C段 用-连接 例: <code class="language-plaintext highlighter-rouge">192.168.0.1-200</code></p>


</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Docker Image</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Docker学习笔记2-镜像</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Docker学习笔记2-镜像 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Docker学习笔记2-镜像" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="获取(拉取)镜像 格式: docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]; 地址的一般格式: &lt;域名/IP&gt;[:端口号] 域名或者IP, 端口号选填; 默认地址: Docker Hub ; 仓库名的一般格式: &lt;用户名&gt;/&lt;软件名&gt; 标签选填; 默认用户名 library ; 下载镜像的过程可以看出分层存储的概念, 一层一层下载" />
<meta property="og:description" content="获取(拉取)镜像 格式: docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]; 地址的一般格式: &lt;域名/IP&gt;[:端口号] 域名或者IP, 端口号选填; 默认地址: Docker Hub ; 仓库名的一般格式: &lt;用户名&gt;/&lt;软件名&gt; 标签选填; 默认用户名 library ; 下载镜像的过程可以看出分层存储的概念, 一层一层下载" />
<link rel="canonical" href="http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%95%9C%E5%83%8F" />
<meta property="og:url" content="http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%95%9C%E5%83%8F" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-13T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Docker学习笔记2-镜像" />
<script type="application/ld+json">
{"description":"获取(拉取)镜像 格式: docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]; 地址的一般格式: &lt;域名/IP&gt;[:端口号] 域名或者IP, 端口号选填; 默认地址: Docker Hub ; 仓库名的一般格式: &lt;用户名&gt;/&lt;软件名&gt; 标签选填; 默认用户名 library ; 下载镜像的过程可以看出分层存储的概念, 一层一层下载","headline":"Docker学习笔记2-镜像","dateModified":"2020-11-13T00:00:00+08:00","url":"http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%95%9C%E5%83%8F","datePublished":"2020-11-13T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E9%95%9C%E5%83%8F"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Docker学习笔记2-镜像</h2>
  <time datetime="2020-11-13T00:00:00+08:00" class="by-line">13 Nov 2020</time>
   
  <span>分类:<a>Docker</a></span>
  
   
  <span>标签:<a>Docker Image</a></span>
  
  <p>获取(拉取)镜像</p>
<ol>
  <li>格式: <code class="language-plaintext highlighter-rouge">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code>;</li>
  <li>地址的一般格式: <code class="language-plaintext highlighter-rouge">&lt;域名/IP&gt;[:端口号]</code> 域名或者IP, 端口号选填;</li>
  <li>默认地址: Docker Hub ;</li>
  <li>仓库名的一般格式: <code class="language-plaintext highlighter-rouge">&lt;用户名&gt;/&lt;软件名&gt;</code> 标签选填;</li>
  <li>默认用户名 <code class="language-plaintext highlighter-rouge">library</code> ;</li>
  <li>下载镜像的过程可以看出分层存储的概念, 一层一层下载</li>
</ol>

<hr />

<p>运行镜像</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">docker run</code></li>
</ol>

<hr />

<p>列出镜像</p>
<ol>
  <li>列出已下载的镜像 <code class="language-plaintext highlighter-rouge">docker image ls</code> ;</li>
  <li>列出的项目: <code class="language-plaintext highlighter-rouge">仓库 标签 镜像ID 创建时间 占用空间</code> ;</li>
  <li>镜像的唯一标识: <code class="language-plaintext highlighter-rouge">镜像ID</code> ID不同才能证明是不同的镜像;</li>
  <li>过滤参数<code class="language-plaintext highlighter-rouge">--filter</code> 简写<code class="language-plaintext highlighter-rouge">docker image ls -f</code>;</li>
  <li>根据创建时间过滤, 之后<code class="language-plaintext highlighter-rouge">since=&lt;仓库&gt;:&lt;标签&gt;</code>, 之前<code class="language-plaintext highlighter-rouge">before=&lt;仓库&gt;:&lt;标签&gt;</code>;</li>
  <li>定义了<code class="language-plaintext highlighter-rouge">LABEL</code>则可以通过<code class="language-plaintext highlighter-rouge">docker image ls -f label=</code>去过滤;</li>
  <li>特定格式显示 <code class="language-plaintext highlighter-rouge">-q</code> 镜像ID列表;</li>
</ol>

<hr />

<p>虚悬镜像</p>
<ol>
  <li>仓库和标签都为 <code class="language-plaintext highlighter-rouge">&lt;none&gt;</code>;</li>
  <li>由于镜像更名引起;</li>
  <li>删除虚悬镜像 <code class="language-plaintext highlighter-rouge">docker image prune</code>;</li>
</ol>

<hr />

<p>中间层镜像</p>
<ol>
  <li>无标签的镜像;</li>
  <li>作为其他上层镜像的依赖, 不能随便删除;</li>
  <li>只会存储一边, 被其他各个上层镜像同时使用, 不用担心重复占用空间;</li>
  <li>默认只列出顶层镜像, <code class="language-plaintext highlighter-rouge">docker image ls -a</code>可查中间层镜像;</li>
</ol>

<hr />

<p>删除本地镜像</p>
<ol>
  <li>格式: <code class="language-plaintext highlighter-rouge">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>;</li>
  <li>
    <镜像>可以是: `镜像短ID、镜像长ID、镜像名 或者 镜像摘要`;
</镜像>
  </li>
  <li>长ID: 完整ID; 短ID: <code class="language-plaintext highlighter-rouge">ls</code>列出的就是短ID, 一般取前几位能区分就行;</li>
  <li>镜像摘要 <code class="language-plaintext highlighter-rouge">docker image ls --digests</code>, 根据摘要删除 <code class="language-plaintext highlighter-rouge">docker image rm &lt;仓库&gt;@摘要</code>;<br /></li>
</ol>

<hr />

<p>删除行为: <code class="language-plaintext highlighter-rouge">Untagged</code> 和 <code class="language-plaintext highlighter-rouge">Deleted</code><br /></p>
<ol>
  <li>Untagged是摘除所有该镜像的标签;</li>
  <li>Deleted才是真正的删除;</li>
</ol>

<hr />

<p>导致Deleted不被触发的情况：<br /></p>
<ol>
  <li>除了指定摘除的标签外, 该镜像还挂有其他标签;</li>
  <li>有其他的镜像依赖于要删除的镜像;</li>
  <li>有正在启动的容器以该镜像为基础;</li>
</ol>

<hr />

<p>Docker Commit</p>
<ol>
  <li>把容器存储层的修改内容保存成一个镜像;</li>
  <li>格式: <code class="language-plaintext highlighter-rouge">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">docker history</code> 查看镜像内的历史记录;</li>
  <li><code class="language-plaintext highlighter-rouge">docker exec</code> 进入镜像内部;</li>
  <li><code class="language-plaintext highlighter-rouge">docker diff</code> 对比改动;</li>
  <li>Docker Commit 属于黑箱操作, 有些改动并不是我们想要的结果, 实际环境应该避免使用;</li>
</ol>

<hr />

<p>Dockerfile – 定制镜像</p>
<ol>
  <li>Dockerfile就是用于定制镜像的一个脚本文件;</li>
  <li>定制镜像就是以一个镜像为基础, 修改一些, 在做成新的镜像;</li>
  <li>FROM 用来指定基础镜像;(FROM scratch 代表从空白镜像开始)</li>
  <li>RUN 用来执行命令
    <ul>
      <li>shell格式: 命令行下的输入;</li>
      <li>exec格式: <code class="language-plaintext highlighter-rouge">RUN ["可执行文件", "参数1", "参数2"]</code>;</li>
    </ul>
  </li>
</ol>

<hr />

<p>构建镜像</p>
<ol>
  <li>格式: <code class="language-plaintext highlighter-rouge">docker build [选项] &lt;上下文路径/URL/-&gt;</code>;</li>
  <li>docker bulid 命令并非是在本地完成的, 而是在远程的Docker引擎中构建的;</li>
  <li>命令中的.代表的是上下文路径而非本地的包含Dockerfile的目录;</li>
</ol>


</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
    		<li>
		<a>
		<span>Docker Container</span>
		<span>&lt;!DOCTYPE html&gt;
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta name="generator" content="Jekyll" />

  <title>Docker学习笔记3-容器</title>

  <link rel="stylesheet" href="/css/main.css" />
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Docker学习笔记3-容器 | sn0wp3ak</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Docker学习笔记3-容器" />
<meta name="author" content="sn0wp3ak" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%AE%B9%E5%99%A8" />
<meta property="og:url" content="http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%AE%B9%E5%99%A8" />
<meta property="og:site_name" content="sn0wp3ak" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-15T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Docker学习笔记3-容器" />
<script type="application/ld+json">
{"headline":"Docker学习笔记3-容器","dateModified":"2020-11-15T00:00:00+08:00","url":"http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%AE%B9%E5%99%A8","datePublished":"2020-11-15T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%AE%B9%E5%99%A8"},"author":{"@type":"Person","name":"sn0wp3ak"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Icons -->
  <link rel="shortcut icon" href="assets/favicon.png" />
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>sn0wp3ak@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/categories"><h2 class="header-link">Category</h2></a>
<a href="/tags"><h2 class="header-link">Tag</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Docker学习笔记3-容器</h2>
  <time datetime="2020-11-15T00:00:00+08:00" class="by-line">15 Nov 2020</time>
   
  <span>分类:<a>Docker</a></span>
  
   
  <span>标签:<a>Docker Container</a></span>
  
  

</article>

      </section>
    </div>
  </div>

   <footer>
  <a>
    <span>
        <b>sn0wp3ak</b>
    </span>
    
    <span>copyleft:) <b>2020</b></span>
  </a>
</footer>


  
</body>

</html></span>
		</a>
		</li>
    
</ul>

:ET