I"i<h3 id="闭包">闭包</h3>
<p><code class="language-plaintext highlighter-rouge">定义</code>: 在函数嵌套的前提下, 内部函数使用了外部函数的变量, 而外部函数则return了内部函数, 在这种情况下, 这个内部函数就称为闭包<br /></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"outer"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">func_in</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    	<span class="c1"># 使用了外部函数的变量a
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"inner %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,))</span>
    <span class="c1"># 把内部函数返回
</span>    <span class="k">return</span> <span class="n">func_in</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">闭包的作用</code>: 可以保存外部函数的变量, 不会随着外部函数调用结束而销毁<br /></p>

<p>注意: 由于闭包引用了外部函数的变量, 所以这个变量会因为没有被及时销毁而占用消耗空间<br /></p>

<p>怎么在闭包的内部<code class="language-plaintext highlighter-rouge">修改</code>从外部函数那里引用来的变量呢？<br />
使用<code class="language-plaintext highlighter-rouge">nonlocal</code>关键字声明即可, 用法类似于全局变量<code class="language-plaintext highlighter-rouge">global</code>声明<br /></p>

<h3 id="装饰器">装饰器</h3>
<p><code class="language-plaintext highlighter-rouge">定义</code>: 给已有函数增加额外功能的函数, 其本质就是一个<code class="language-plaintext highlighter-rouge">闭包</code>函数<br /></p>

<p>特点:</p>
<ol>
  <li>不会修改已有函数的源代码</li>
  <li>不会修改已有函数的调用方式</li>
  <li>给已有函数增加额外的功能</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"inner"</span><span class="p">)</span>
	<span class="n">fn</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"func"</span><span class="p">)</span>

<span class="c1"># 手动装饰函数
</span><span class="n">func</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

<span class="c1"># 调用装饰后的函数
</span><span class="n">func</span><span class="p">()</span>
</code></pre></div></div>
<p>执行结果</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inner</span>
<span class="n">func</span>
</code></pre></div></div>

<ul>
  <li>装饰器函数只有一个参数, 且必须是函数类型</li>
  <li>装饰器不允许修改原来的函数, 仅增加额外功能</li>
</ul>

<p>装饰器的语法糖:<br /></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">check</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"func"</span><span class="p">)</span>
</code></pre></div></div>

<p>其实语法糖就是一种简写, 本质还是手动装饰的那行代码<br /></p>

<p>装饰器的执行时间:</p>
<ul>
  <li>在加载模块时立即执行</li>
</ul>

<h3 id="通用装饰器">通用装饰器</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>
	<span class="c1"># 扩展功能
</span>	<span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">inner</span>
    
    
<span class="k">def</span> <span class="nf">fn</span><span class="p">():</span>
    <span class="k">pass</span>
    
    
<span class="n">fn</span><span class="p">()</span>
</code></pre></div></div>

:ET